% From mitthesis package
% Version: 1.07, 2024/09/26
% Documentation: https://ctan.org/pkg/mitthesis


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{CadetBlue!15!white},   
    commentstyle=\color{Red3},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{Blue3},
    basicstyle=\small\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python,
    basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}%
\lstset{language=Python,style={mystyle}}%

\lstdefinestyle{seudocode}{
    backgroundcolor=\color{Goldenrod!30!white},   
    commentstyle=\color{Red3},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{Blue3},
    basicstyle=\small\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python,
    basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}%


\chapter{Problemas comunes}
\label{problemasComunes}

En este capítulo se enumeran problemas comunes en el desarrollo de software embebido de control, extraídos principalmente del libro ``\textit{Design Patterns for Embedded Systems in C: An Embedded Software Engineering Toolkit}'' \cite{douglass}. Cabe recordar que, si bien el título del libro indica que propone patrones de diseño, las soluciones que presenta no lo son realmente y, en algunos casos, resultan inadecuadas. Además, se analiza la solución de diseño propuesta en dicho libro y, a su vez, se aporta una alternativa desde la perspectiva de la Ingeniería del Software (\gls{IS}) enfocada en el diseño para el cambio. En muchos casos, se identifica la posibilidad de aplicar ciertos patrones de diseño descritos en \cite{Gamma:1995:DPE:186897}, mientras que en otros se utilizan conceptos y metodologías clave del diseño para el cambio, propuestos por David L. Parnas \cite{Parnas02, Parnas1972, parnas1977abstract}.


\minitoc



\section{Acceso al hardware}
\label{Accesoalhardware}
Una de las características distintivas de los sistemas embebidos es que trabajan directamente con dispositivos de hardware. Cada uno de estos tiene sus propios protocolos de comunicación y estándares de funcionamiento (por ejemplo, direcciones de memoria, codificación de bits, etc), por lo tanto el software se debe ajustar a sus requerimientos. Como se puede entender esta tarea no es simple y puede demandar mucho esfuerzo cada vez que se quiera modificar o agregar un componente de hardware. A su vez, puede que múltiples módulos de un sistema embebido quieran acceder al dispositivo, por lo que cada uno debe encargarse de la comunicación creando código repetido y complicando aún más las modificaciones. 

Para entender los inconvenientes que puede conllevar no diseñar pensando en el cambio se trabajará sobre un ejemplo simple. Suponga que se tiene un sistema embebido que debe controlar un motor de corriente continua (\gls{DC}) y que el software para hacerlo corre en un \gls{MCU} de la empresa \gls{arduinoEmpre}. Los requerimientos definen que es necesario poder asignar el sentido de giro (horario o antihorario) y la velocidad de rotación del motor según se necesite. Para controlar el motor se utiliza una placa \gls{DRV8838}, la cual se coloca entre el \gls{MCU} y el motor. Es necesario ya que el microcontrolador y su plataforma no pueden manejar las potencias requeridas para hacer funcionar el dispositivo. Podemos ver el conexionado de la mismo en la Figura \ref{drv8838}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.65\linewidth]{drv8838.png}
    \caption{Conexionado de la placa de control DRV8838.}
    \label{drv8838}
\end{figure}

Como se observa la placa \gls{DRV8838} tiene múltiples pines. De estos podemos identificar dos grupos: los que aparecen a la izquierda, que llamaremos pines de entrada, y los de la derecha, que denominaremos pines de salida. El \gls{MCU} se conecta a los pines de entrada y, a través de estos, controlará el funcionamiento de la placa. En cambio, en los pines de salida se conecta el motor y transmiten la potencia necesaria.

Dentro de cada uno de estos grupos se encuentran pines destinados a la comunicación entre componentes, y otros que se utilizan para alimentar tanto la lógica de la placa \gls{DRV8838} como al motor. Estos últimos son \textit{GND}, \textit{VCC} y \textit{VIN}. Los pines de control de entrada son \textit{ENABLE}, \textit{PHASE} y \textit{SLEEP}, aunque en este ejemplo se utilizarán solo los dos primeros para simplificar la explicación. De todas formas, en la Tabla \ref{funciones_pin_drv8838} se puede consultar la función de cada pin y si la señal correspondiente es analógica o digital. Por último, \textit{OUT1}, \textit{OUT2} y \textit{VMM} son los pines de salida hacia el motor, y son los que finalmente transmiten la tensión y potencia necesarias para lograr el comportamiento deseado del motor.

\begin{table}[h]
\centering
\begin{tabular}{lllll}
\cline{1-3}
\multicolumn{1}{|l|}{PHASE}  & \multicolumn{1}{l|}{dirección de rotación} & \multicolumn{1}{l|}{digital}   &  &  \\ \cline{1-3}
\multicolumn{1}{|l|}{ENABLE} & \multicolumn{1}{l|}{velocidad de rotación} & \multicolumn{1}{l|}{analógico} &  &  \\ \cline{1-3}
\multicolumn{1}{|l|}{SLEEP}  & \multicolumn{1}{l|}{liberar fuerza}        & \multicolumn{1}{l|}{digital}   &  &  \\ \cline{1-3}
                             &                                            &                                &  & 
\end{tabular}
\caption{Funciones de cada pin del módulo DRV8838}
\label{funciones_pin_drv8838}
\end{table}

\gls{MCU} se conecta a los pines de \textit{ENABLE}, \textit{PHASE} y \textit{SLEEP} el software deberá gestionarlos. Pero, como se mencionó, para acotar el ejemplo se restringieron los requerimientos y para complirlos solo necesitaremos trabajar con los pines \textit{ENABLE} y \textit{PHASE}. Tendremos entonces dos cables conectados desde \gls{microcontrolador} a la placa \gls{DRV8838}, uno que se dirige a \textit{ENABLE} y otro a \textit{PHASE}. En el pseudo-código \ref{listing1} se encuentran las lineas necesarias para poder configurar el motor para luego poder utilizarlo en el resto del sistema. En estas se establece que el pin número siete del \gls{MCU} está conectado a el pin \textit{PHASE} y que el nueve a \textit{ENABLE}. Y a su vez se inicializa el pin dentro del software como pin de salida (\textit{OUTPUT}). Esto es necesario para que otras funciones que se llamen en el futuro se comporten como esperamos.

\begin{lstlisting}[caption=Configuración inicial del control del motor DC.,label={listing1}]
# Notar que los numeros asignados a los pines son arbitrarios dentro del conjunto de pines disponibles en nuestro Arduino.

# Constantes globales
DIR_pin = 7
VEL_pin = 9

def setup()
     .
     .
     .
  pinMode(DIR_pin, OUTPUT)
  pinMode(VEL_pin, OUTPUT)
     .
     .
     .
\end{lstlisting}


Una vez configurados los pines podemos hacer uso de las funciones \verb|pinMode|, \verb|digitalWrite| y \verb|analogWrite| provistas por el entorno de desarrollo de Arduino. Sus nombres son bastastantes descriptivos de su comportamiento, \verb|pinMode| configura el modo de operacion de un PIN en particular, puede ser \verb|OUTPUT| o \verb|INPUT| (entrada o salida). Y tanto \verb|digitalWrite| como \verb|analogWrite|, configuran en un PIN el valor especificado. \verb|digitalWrite| admite dos valores definidos por el entorno \verb|HIGH| y \verb|DOWN|. Por lo tanto, si se quiere establecer la máxima velocidad de giro en el motor se haría algo como en el Código \ref{codigoMax}. Y en caso de querer detenerlo usamos \verb|analogWrite| de la forma que se muestra en el Código \ref{codigoDet}.

\begin{lstlisting}[caption=Establecer 
máxima velocidad giro en sentido horario.,label={codigoMax}]
digitalWrite(DIR_pin, HIGH)
analogWrite(VEL_pin, 255) # Maximo valor aceptado, PWM siempre encendido
\end{lstlisting}

\begin{lstlisting}[caption=Detener giro del motor DC., label={codigoDet}]
analogWrite(VEL_pin, 0)
\end{lstlisting}

No es necesario entender por completo qué hace cada llamada, pero sí es importante comprender que ejecutar el Código \ref{codigoMax} y \ref{codigoDet} es fundamental para controlar el motor. Es decir, cualquier cliente del motor en el sistema debe saber que, para hacer que el motor gire a la máxima velocidad, es necesario ejecutar las dos lineas mostradas en el Código \ref{codigoMax} sobre los pines correspondientes al motor. Por ejemplo, si se desea realizar una acción con el motor en función del valor de alguna variable del sistema (\verb|valor|), \textbf{tradicionalmente} se implementa algo similar al código mostrado en el Código \ref{listingMotor}. En el cual si se cumple la condición de que \verb|valor| es mayor a 100 se ordenará al motor que avance a máxima velocidad, en caso contrario se indicará velocidad nula.

\begin{lstlisting}[caption=Ejemplo uso del motor DC.,label={listingMotor}]
def controlar_motor()

	if (valor > 100)
    	digitalWrite(DIR_pin, HIGH)
	    analogWrite(VEL_pin, 255)
	else
	    analogWrite(VEL_pin, 0)

\end{lstlisting}

¿Qué problemas tiene esta estrategia de cara al cambio?
\begin{itemize}
	\item Consideremos un caso en el que un segundo motor es agregado. Este es controlado por otra placa \gls{DRV8838} que también se conecta con dos pines al \gls{MCU}. Para poder utilizarlo en el código debemos definir al, al igual que con el primer motor, los dos pines que utilizará, supongamos en este caso \verb|DIR_pin2| y \verb|VEL_pin2|. Si queremos modificar la función \verb|controlar_motor| para incluir a este nuevo motor podríamos hacer algo como en el Código \ref{motor2}.
	
\begin{lstlisting}[caption=Extención de la función controlar\_motor para controlar dos motores.,label={motor2}]
def controlar_motor(motor)

	if (valor > 100)
		if (motor = IDMotor1)
    		digitalWrite(DIR_pin, HIGH)
	    	analogWrite(VEL_pin, 255)
	    else if (motor = IDMotor2)
	    	digitalWrite(DIR_pin2, HIGH)
	    	analogWrite(VEL_pin2, 255)
	    	.
	    	.
	    	.
	else
		if (motor = IDMotor1)
	    	analogWrite(VEL_pin, 0)
	    else if (motor = IDMotor2)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.

\end{lstlisting}
	
La modificación consiste en verificar que motor es el que se quiere manipular y en base a eso enviar la señal a traves de los pines correspondientes. Pero, ¿qué pasaría si se quiere añadir un tercer motor? Deberíamos agregar aún mas sentencias \verb|if else|, extendiendo aun más el código. ¿Y si debemos realizar operaciones diferentes según cada motor? Por ejemplo, en el caso que \verb|valor| sea mayor a 100 con el motor 1 se debe establecer velocidad máxima pero con el motor 2 nula. El cambio en el código es pequeño (ver Código \ref{motor2mod}), solo cambia un valor en la linea 9. Pero introduce complejidad en la lectura y comprensión facilitando la introducción de errores en futuras modificaciones. Es insostenible en el tiempo este enfoque de diseño.
\begin{lstlisting}[caption=Modificación de la función controlar\_motor para cambiar comportamiento al utilizar el motor 2.,label={motor2mod}]
def controlar_motor(motor)

	if (valor > 100)
		if (motor = IDMotor1)
    		digitalWrite(DIR_pin, HIGH)
	    	analogWrite(VEL_pin, 255)
		else if (motor = IDMotor2)
	    	digitalWrite(DIR_pin2, HIGH)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.
	else
		if (motor = IDMotor1)
	    	analogWrite(VEL_pin, 0)
		else if (motor = IDMotor2)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.

\end{lstlisting}
	\item Imagine el caso en el que por cierto motivo se debe invertir el sentido de giro del motor, de manera que lo que era ir giro horario ahora es anti horario. Para llevar a cabo el cambio, debemos modificar \textbf{todas} las llamadas a \verb|digitalWrite(DIR_pin, HIGH)|, tanto en el código que de la función \verb|controlar_motor| como en el resto del sistema, cambiando \verb|HIGH| por \verb|DOWN| y viceversa. Por ejemplo, en el Código \ref{motor2mod} debemos modificar las lineas 5 y 8. Es fácil cometer un error y dejar al sistema en un estado inconsistente. Ni hablar en el caso que se planteó en el punto anterior, puede ser necesario discriminar entre motores. La precaución a la hora de modificar debe ser mayor aún y a su vez la probabilidad de introducir errores aumenta.
   
    \item Por cierto motivo se descompuso la placa controladora del motor 1, y no se consigue un reemplazo idéntico, sino que se adquiere una nueva placa de otra marca, por ejemplo, una \textit{Pololu Simple Motor Controller G2}. En este caso, este placa no utiliza la misma interfaz de control que el \gls{DVR8838}, sino para controlarla se accede a ella mediante comunicación serial (utiliza un solo pin especifico). Incluso utilizando las herramientas provistas por el entorno de \gls{arduino}, el nuevo código de configuración (ver Codigo \ref{listingDistinto}) y uso (ver Codigos \ref{maxSerial} y \ref{detSerial}) difiere significativamente del anterior (Codigo \ref{listing1} para configuración y Codigos \ref{codigoMax} y \ref{codigoDet} para uso).
\begin{lstlisting}[caption=Configuración de la placa de control del motor DC utiliza comunicación serie., label={listingDistinto}]
def set_up() 
    .
    .
    .
    Serial.begin(9000)
    .
    .
    .

    \end{lstlisting}
\begin{lstlisting}[caption=Establecer máxima velocidad giro horario para el caso de comunicación en serie., label={maxSerial}]
Serial.write(0xAA)
Serial.write(0x0C)
Serial.write(0x85)
Serial.write(0x7F)
\end{lstlisting}
\begin{lstlisting}[caption=Establecer detención para el caso de comunicación en serie., label={detSerial}]
Serial.write(0xAA)
Serial.write(0x0C)
Serial.write(0xE0)
\end{lstlisting}
    Por lo tanto debemos modificar todos los usos de la antigua implementación por la nueva, lo cual además requerir un esfuerzo considerable, da pie a errores y obliga a reverificar código que ya se sabía que funcionaba correctamente. Se debe modificar las lineas 5, 6 y 15 de la función \verb|controlar_motor| de la manera mostrada en el Código \ref{motor1serial}.

\begin{lstlisting}[caption=Modificación de la función controlar\_motor para utilizar placa de control serial para controlar el motor 1.,label={motor1serial}]
def controlar_motor(motor)

	if (valor > 100)
		if (motor = IDMotor1)
    		Serial.write(0xAA)
				Serial.write(0x0C)
				Serial.write(0x85)
				Serial.write(0x7F)
		else if (motor = IDMotor2)
				digitalWrite(DIR_pin2, HIGH)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.
	else
		if (motor = IDMotor1)
	    	Serial.write(0xAA)
				Serial.write(0x0C)
				Serial.write(0xE0)
		else if (motor = IDMotor2)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.

\end{lstlisting}

Pero... ¿y si en el futuro se consigue la placa \gls{DRV8838}? Muchas veces se suele añadir una bandera que indique el tipo de hardware. En este caso, se podría definir una constante, por ejemplo, \verb|TIPO_MOTOR1|, que identifique el tipo de placa controladora. Al incorporar esta bandera en nuestra función \verb|controlar_motor|, se obtiene el Código \ref{motorBandera}.

\begin{lstlisting}[caption=Modificación de la función controlar\_motor para utilizar bandera indicadora de tipo de placa controladora.,label={motorBandera}]
def controlar_motor(motor)

	if (valor > 100)
		if (motor = IDMotor1)
			if (TIPO_MOTOR1 = DVR8838):
			    digitalWrite(DIR_pin, HIGH)
	    		analogWrite(VEL_pin, 255)
			else if (TIPO_MOTOR1 = Pololu):
    			Serial.write(0xAA)
					Serial.write(0x0C)
					Serial.write(0x85)
					Serial.write(0x7F)
		else if (motor = IDMotor2)
	    	digitalWrite(DIR_pin2, HIGH)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.
	else
		if (motor = IDMotor1)
			if (TIPO_MOTOR1 = DVR8838):
				analogWrite(VEL_pin1, 255)
			else if (TIPO_MOTOR1 = Pololu):
	    	Serial.write(0xAA)
				Serial.write(0x0C)
				Serial.write(0xE0)
	    else if (motor = IDMotor2)
	    	analogWrite(VEL_pin2, 0)
	    	.
	    	.
	    	.

\end{lstlisting}

Esto no es una buena solución, ya que lo unico que logra es generar más dificulad a la hora de introducir un nuevo cambio. Ahora, si se debe cambiar la lógica de la función, debemos tener en cuenta más lineas a modificar. Introduciendo así más posibilidades de cometer errores.

    \item Claramente, el código obtenido es poco claro; es decir, no resulta fácil comprender de qué se trata una determinada porción de código con solo leerla. Basta con intentar entender la función del Código \ref{motorBandera} para comprobarlo. A su vez, el código resulta difícil de modificar, ya que requiere un esfuerzo adicional de comprensión antes de poder aplicar cualquier cambio. En el ejemplo, la lógica principal de la función es sencilla —solo una sentencia condicional—, pero en general las funciones suelen ser más complejas e incluyen múltiples sentencias, estructuras anidadas y bucles.


\end{itemize}

En el libro, la solución de este problema es nombrada como un patrón de diseño, el patrón \textit{``Hardware Proxy''}. Pero desde el punto de vista de la IS, no es un patrón de diseño, sino uno de los principios fundamentales de la  IS, que es el \gls{dboi}.

\declareCMod{MotorDC}

Estos inconvenientes son derivados de que el \textit{hardware} comprende un ítem de cambio frecuente; por lo que si seguimos la metodología de Parnas (ver sección \ref{metoParnas}), se debe aislar ese posible cambio en un módulo. En el ejemplo que se está trabajado, se debe crear un módulo que encapsula el hardware en cuestión, el motor \gls{DC}. Este módulo oculta cómo debe ser usado el hardware y provee una interfaz lo suficientemente insensible a la implementación. Es decir, al momento de confeccionar la interfaz del módulo se debe pensar en lo que el motor siempre va a hacer independientemente de los posibles cambios que sufra el hardware subyacente. Para esto, se debe elegir la cantidad de mínima de métodos del modo más abstracto posible, sin agregar métodos que puedan ser reemplazados utilizando otros que ya fueron definidos \cite{Parnas02, parnas1977abstract}.
Un motor \gls{DC} siempre recibirá ordenes para definir su sentido y velocidad de rotación. La Figura \ref{interfazMotor} presenta la interfaz del módulo \MotorDC que encapsula el hardware relacionado al motor.

\begin{figure}[H]
\caption{Interfaz MotorDC}
\label{interfazMotor}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=-3]{MotorDC}
{
MotorDC(i: Pin, i: Pin)
}
{
    
    setDir(i: Dir) \\ 
    setVel(i: Vel) \\
}
\end{tikzpicture}
\end{center}
\end{figure}

Si se cuenta con dos o mas motores del mismo tipo, se crearán dos a mas instancias del módulo. Para esto el contrsuctor recibirá como parámetros los pines de control, el método de \verb|setDir| toma el valor de dirección a establecer y el input de \verb|setVel| el valor de velocidad deseado. En el Código \ref{constructorMotor} se puede ver un ejemplo de una posible implementación de esta interfaz utilizando el controlador \gls{DVR8838}.

\begin{lstlisting}[caption=Posible implementación de la interfaz del módulo MotorDC.,label={constructorMotor}]
def MotorDC(dir_pin, vel_pin);
    pinMode(this.dir_pin, OUTPUT)
    pinMode(this.vel_pin, OUTPUT)


def setDir(dir) 
    if (dir == HORARIO)
        digitalWrite(dir_pin, HIGH)
    else
        digitalWrite(dir_pin, DOWN)
        

def setVel(vel)
    analogWrite(vel_pin, vel)

\end{lstlisting}

En el código \ref{ejeploUsoMotor} se evidencian las primeras ventajas, el uso del motor en el código es mucho más claro en comparación al diseño tradicional, donde teniamos que escribir las lineas de los Códigos \ref{listing1} y \ref{codigoMax} para lograr lo mismo.

\begin{lstlisting}[caption=Ejemplo de uso de la interfaz del módulo MotorDC, label={ejeploUsoMotor}]
motor = MotorDC(1, 2)

motor.setDir(Dir.HORARIO)
motor.setVel(255)
\end{lstlisting}

Además, si se debe invertir el sentido de giro como en el ejemplo propuesto al comienzo de la sección, es tan fácil como cambiar la implementación del método \verb|setDir|, los clientes no notarán el cambio. A su vez, si se quiere controlar otro motor es posible hacerlo fácilmente como en el Código \ref{ejemploOtroMotor}. 

\begin{lstlisting}[caption=Ejemplo control nuevo motor DC.,label={ejemploOtroMotor}]
motor_delantero = MotorDC(18, 19)

motor_delantero.setDir(ANTIHORARIO)
motor_delantero.setVel(10)
\end{lstlisting}


En caso de un cambio de componente de hardware, como el explicado anteriormente, los clientes del módulo no lo notarán, dado que la interfaz se mantendrá intacta. Por ejemplo, para el motor que utiliza comunicación serie, \verb|setDir| será redefinida como en el código \ref{nuevaSetDir} teniendo que solo volver a verificar el módulo \MotorDC.

\begin{lstlisting}[caption=Implementación método setVel para el motor que utiliza comunicación serie.,label={nuevaSetDir}]
def setVel(vel)
        serial.write(0xAA;
        serial.write(0x0C)
        hex_vel = int_to_hex(vel)
        serial.write(hex_vel)
\end{lstlisting}

Sin embargo, haciendo uso del concepto de herencia de interfaz y la noción de abierto-cerrado (explicados en la sección \ref{ingso}). Esto permite reutilizar módulos ya implementados y abstraer aún más la implementación. Para hacerlo se define un módulo abstraco \textit{\MotorDC} del cual hereda la interfaz cada modelo o combinación de motor y placa controladora. ELa Figura \ref{estructuraHerencia} presenta la estructura de interfaces de esta solución.

\begin{figure}[H]
\caption{Módulo MotorDC abstracto y estructura de herencia.}
\label{estructuraHerencia}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=0,type=abstract]{MotorDC}
{}
{
    \umlvirt{setDir(i: Dir)} \\ 
    \umlvirt{setVel(i: Vel)} \\
}

\umlclass[x=-3, y=-4]{MotorDCDVR8838}
{
	MotorDC(i: Pin, i: Pin)
}
{
    setDir(i: Dir) \\ 
    setVel(i: Vel) \\
}
\umlclass[x=3, y=-4]{MotorDCG2}
{
	MotorDC(i: Serial)
}
{
    setDir(i: Dir) \\ 
    setVel(i: Vel) \\
}
\umlinherit[geometry=|-|]{MotorDCDVR8838}{MotorDC}
\umlinherit[geometry=|-|]{MotorDCG2}{MotorDC}
\end{tikzpicture}
\end{center}
\end{figure}

El cliente solo sabe que manipula un elemento \textit{\MotorDC}, no tiene noción con cual de los dos tipos de de placa controladora esta tratando. También es posible agregar más herederos, uno por cada modelo de placa controladora/motor, y reutilizar las módulos implementados en caso de utilizar hardware idéntico.

Siguiendo con el ejemplo de la función \verb|controlar_motor| veamos en la Figura \ref{motorEncapsulado} cómo es una posible implementación de esta misma utilizando la encapsulación del hardware propuesta. Con esta solución el codigo de la funcion no deberá ser modificado por más que cambien las marcas/tipos de placas controladoras.

\begin{lstlisting}[caption=Implementación de la función controlar\_motor utilizando encapsulación del hardware.,label={motorEncapsulado}]
def controlar_motor(motor: MotorDC)
	if (valor > 100)
		motor.setDir(HORARIO)
		motor.setDir(VelMaxima)
	else
		motor.setDir(VelNula)
\end{lstlisting}

De esta manera se siguen las prácticas recomendadas en la \gls{IS} \cite{ShawGarlan1996, ghezzi2003, bass2003, DBLP:books/daglib/0030743} y se obtiene un diseño orientado al cambio \cite{Gamma:1995:DPE:186897}.

\section{Interfaces que no se ajustan perfectamente}
Muchas veces el proveedor del hardware incluye con este librerías para su control, otras veces se consiguen en internet o se extraen de previos proyectos. Esto permite ahorrar tiempo de implementación, pero puede causar algunos inconvenientes si no se tiene en cuenta al cambio.

Tradicionalmente, se toman las librerías necesarias para controlar el hardware y se las utiliza directamente a lo largo del sistema. Lo que provoca que ante un cambio de hardware se debe modificar todos los usos de la librería con el nuevo código. Veamos un ejemplo en donde se evidenciará el inconveniente y cómo podemos anticiarnos al mismo.

Suponga el siguiente ejemplo: en un cierto sistema embebido se utiliza un display de 7 segmentos que forman un 8. Encendiendo o apagando independientemente cada segmento, se pueden mostrar distintos caracteres. Este display es de 4 dígitos y se emplea para mostrar la temperatura de funcionamiento y la posición, en grados, de cierto actuador, como se muestra en la figura \ref{fig:enter-label}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{display.png}
    \caption{Display 7 segmentos 4 digitos}
    \label{fig:enter-label}
\end{figure}

\declareCMod{LibAcme}
\declareCMod{LibEmca}

Este display recibe la información utilizando comunicación en serie, con un protocolo propio del fabricante. Para facilitar su uso, el fabricante brinda una librería llamada \LibAcme que implementa la comunicación y provee funciones simples de usar, tales como \verb|escribir(i: string): bool| y \verb|limpiar()|. La primera intenta escribir la cadena de caracteres indicada, pero solo lo hace si el display no está mostrando nada. En ese caso devuelve \verb|True| indicando que la acción fue completada con éxito. En caso contrario, es decir el display está mostrando texto al momento de llamar el método, retorna \verb|False|. \verb|limpiar()|, siempre limpia el display. Por lo tanto, se implementó el sistema utilizando las funciones provistas. Para comunicarse, múltiples módulos llaman esas funciones de la manera expuesta en el Código \ref{usoLibAcme}.

\begin{lstlisting}[label={usoLibAcme}, caption=Ejemplo de uso de la libreria LibAcme.]
libAcme = LibAcme()

if libAcme.escribir("24")
	print("El display estaba vacio, se pudo escribir el nuevo texto")
else
	print("El display esta ocupado mostrando algo, no se pudo escribir")

\end{lstlisting}

En cierto momento, el módulo display dejó de funcionar y fue reemplazado por otro de un fabricante distinto, el cual utiliza un protocolo de comunicación diferente. Al igual que en el caso anterior, la empresa provee una librería \LibEmca para utilizar el nuevo display. Sin embargo, la interfaz no es la misma que la anterior, e incluso algunos comportamientos también difieren.

Por ejemplo, en la primera librería, el método de escritura devolvía \verb|False| si se intentaba escribir mientras el display ya estaba mostrando información. En cambio, en la nueva implementación, si el display está mostrando algo, el nuevo texto lo sobrescribe de inmediato. No obstante, esta nueva librería proporciona un método adicional \verb|get_current(): string| que permite consultar el contenido que se está mostrando en el momento en que es invocado.

Tradicionalmente, para utilizar el nuevo display, se modifican todas las llamadas a las funciones de la librería anterior en todo el sistema, incorporando la nueva lógica. En nuestro ejemplo, el Código \ref{usoLibAcme} debe ser reemplazado por el Código \ref{usoLibEmca}. Si bien el cambio puede parecer superficial, es importante considerar que con cada modificación será necesario actualizar manualmente y reverificar \textbf{todos} los usos de la librería a lo largo del sistema.
\begin{lstlisting}[label={usoLibEmca}, caption=Ejemplo de modificaciones necesarias para adaptar la nueva librería.]
libEmca = LibEmca()

// Con EMCA

if libEmca.get_current() == ""
	libEmca.imprimir("Hola mundo!")
	print("El display estaba vacio, se pudo escribir el nuevo texto")
else
	print("El display esta ocupado mostrando algo, no se pudo escribir")


\end{lstlisting}

Además, este es un ejemplo simple; en el mundo real, los cambios pueden ser mucho más complejos en su lógica y de distinta naturaleza. Este diseño puede representarse como se muestra en la Figura \ref{configOri}: un módulo que constituye la librería del fabricante y otro que actúa como cliente de esta, es decir, el resto del sistema.


\begin{figure}[H]
\caption{Diseño tradicional del uso de la libreria del fabricante.}
\label{configOri}
\begin{center}
\begin{tikzpicture}\sf
\umlsimpleclass[]{Cliente}

\umlclass[right=1.5cm of Cliente]{LibAcme}
{}
{
escribir(i: string): bool  \\
limpiar()
}

\umluniassoc[]{Cliente}{LibAcme}


\umlnote[below left=0.5cm and 0.5cm of LibAcme, width=3cm]{LibAcme}{
Librería externa.
}


\end{tikzpicture}
\end{center}
\end{figure}

Este diseño presenta un fuerte acoplamiento entre el \Cliente y la \LibAcme, por lo que cualquier cambio en el hardware repercutirá en el resto del sistema, trayendo consigo todas las desventajas mencionadas tanto en este capítulo como en el anterior. Se podría decir que el principal problema radica en que no se siguió la metodología de diseño propuesta por Parnas \cite{Parnas1972}. El hardware representa un ítem con alta probabilidad de cambio, por lo tanto, debe ser encapsulado.

En el libro de Douglass \cite{douglass} se observa que, en la práctica, este tipo de escenarios son comunes: ya se tiene un sistema funcionando y se produce un cambio de hardware. Por ello, se intentará proponer una posible solución desde el punto de vista de la \gls{IS}. En lugar de reescribir todo el sistema, veremos cómo, aplicando un patrón de diseño de Gamma \cite{Gamma:1995:DPE:186897}, es posible adaptar el sistema y preparar el diseño del mismo para futuros cambios de índole similar.
\declareAMod{Display}
Para encapsular el hardware sin modificar todo el sistema se creará un módulo abstracto llamado \Display. En su interfaz proveerá los mismos métodos que \LibAcme de esta manera evitaremos cambiar la implementación del resto del sistema. Al compartir interfaz podemos decir que \LibAcme hereda la interfaz de \Display, esto lo podemos ver en la Figura {configUsando}.

\begin{figure}[H]
\caption{Introducción del nuevo módulo abstracto\Display.}
\label{configUsando}
\begin{center}
\begin{tikzpicture}\sf
\umlsimpleclass[]{Cliente}

\umlclass[right=1.5cm of Cliente,type=abstract]{Display}
{}
{
\umlvirt{escribir(i: string): bool}  \\
\umlvirt{limpiar()}
}

\umlclass[right=0.5cm of Cliente,below=2cm of Cliente]{LibAcme}
{}
{
escribir(i: string): bool  \\
limpiar()
}

\umluniassoc[]{Cliente}{Display}
\umlinherit[geometry=|-|]{LibAcme}{Display}


\end{tikzpicture}
\end{center}
\end{figure}
\declareCMod{DisplayEmca}
Como mencionamos, \LibEmca se utiliza para controlar el nuevo display, pero su interfaz y funcionalidad no son las mismas que las de \LibAcme. Por lo tanto, aplicaremos el patrón \textit{Adapter} (Adaptador) propuesto por Gamma \cite{Gamma:1995:DPE:186897}. Este patrón consiste, en este caso, en crear un módulo \DisplayEmca, que se encarga de adaptar la interfaz de \LibEmca a la de \Display. Es decir, utilizará los métodos de \LibEmca para implementar la funcionalidad esperada por los métodos de \Display. De esta manera, se obtiene la estructura de módulos mostrada en la Figura \ref{configNueva}.

\begin{figure}[H]
\caption{Diseño aplicando el patrón \textit{Adapter}.}
\label{configNueva}
\begin{center}
\begin{tikzpicture}\sf
\umlsimpleclass[x=-4.5,y=1]{Cliente}

\umlclass[x=0,y=1,type=abstract]{Display}
{}
{
\umlvirt{escribir(i: str): bool}  \\
\umlvirt{limpiar()}
}
\umlclass[x=-2.5,y=-3]{LibAcme}
{}
{
escribir(i: str): bool  \\
limpiar()
}
\umlclass[x=2.5,y=-3]{DisplayEmca}
{}
{
escribir(i: str): bool  \\
limpiar()
}
\umlclass[x=8,y=0.5]{LibEmca}
{}
{
imprimir(i: str)  \\
get\_current(): str
}
umluniassoc
\umlinherit[geometry=|-|]{LibAcme}{Display}
\umlinherit[geometry=|-|]{DisplayEmca}{Display}
\umluniassoc[]{Cliente}{Display}
\umluniassoc[geometry=-|-]{DisplayEmca}{LibEmca}

\umlnote[below=0.5cm of LibEmca, width=3cm]{LibEmca}{
Librería externa.
}
\end{tikzpicture}
\end{center}
\end{figure}

No olvidar que cada aplicación de un patrón de diseño debe ser seguida por su correspondiente documentación \textbf{2MIL}. En este caso se la presenta en la Figura \ref{docAdapter}.

\begin{figure}[H]
\caption{Documentación de la aplicación del patrón Adapter al ejemplo del display.}
\label{docAdapter}
\begin{pattern}[]{Adaptar nuevo controlador de display}{Algorithm}{idFigAlg}
\based{Adaptador (Adapter)}
\why{\textbf{Cambios previstos}: Se pueden agregar diferentes displays pero manteniendo una interfaz común.

\textbf{Funcionalidad}: En caso de agregar un nuevo display que provee una intefaz diferente a la utilizada en el sistema, se crea un módulo que la adapta para que corresponda a la usada.
}
\assigns
\is{Display}{Target}
\is{LibEmca}{Adaptee}
\is{DisplayEmca}{Adapter}
\end{pattern}
\end{figure}


En el Código \ref{codigoAdapter} se presenta un ejemplo de implementación del módulo \DisplayEmca. En este se utilizan los métodos provistos por la librería del fabricante, y se emula la interfaz de \Display. De este modo, se permite reemplazar el hardware sin necesidad de modificar ni reverificar ninguna otra parte del sistema.

\begin{lstlisting}[label={codigoAdapter}, caption=Ejemplo de implementación del módulo \ControlEmca]
escribir(string palabra)
    if (libEmca.get_current() != "")
        return false
	else
    	libEmca.imprimir(cadena)
    	return true

limpiar()
    libEmca.imprimir("")
\end{lstlisting}

Las ventajas de aplicar este patrón en esta situación particular en la cual se parte de un diseño \textbf{no} oriendatado al cambio son:

\begin{itemize}

\item Facilitar la sustitución de hardware: permite cambiar el display sin necesidad de modificar el código del cliente, reduciendo el impacto del cambio de hardware en el sistema.

\item Mantiener la coherencia en la interfaz: el cliente sigue interactuando con la misma interfaz abstracta (\Display), evitando la necesidad de modificar múltiples módulos en el sistema.

\item Minimizar el riesgo de errores: al encapsular las diferencias de implementación en el adaptador (\DisplayEmca), se reduce la posibilidad de introducir errores al modificar manualmente todas las llamadas en el código.

\item Mejorar la mantenibilidad: cualquier nuevo display con una librearía de control solo requiere la creación de un nuevo adaptador.

\item Se promueve la reutilización de código: la abstracción permite reutilizar la lógica del cliente sin importar qué display se use, evitando la duplicación de código y mejorando la modularidad.
\end{itemize}


\section{Obtención de información}
\label{obtInfo}

Generalmente una tarea importante que tienen los sistemas embebidos es recavar información proveniente de sensores. Existen diferentes formas en las que los sensores transmiten información al sistema. Algunos, por ejemplo un sensor de temperatura, establece en el pin en el que está conectado un valor de tensión, por lo que el sistema solo debe consultar el valor del pin. Otros, en cambio, se comunican mediante interrupciones; por ejemplo un sensor de efecto \gls{hall} genera una interrupción por cada detección de campo magnético. Por lo tanto, si lo estamos usando para calcular las \gls{RPM} de un componente giratorio, debemos llevar una cuenta de las interrupciones que generó en cierto periodo de tiempo y realizar una operación matemática. Evidentemente, es necesario que alguna porción de nuestro sistema se encargue de hacerlo y maneje las interrupciones generadas por el sensor. Algo similar pasa con otro tipos de dispositivos como joysticks, botones, etc.

Tradicionalmente, esta tarea se centraliza en un único módulo que provee dos métodos: uno encargado de manejar la interrupción, procesar y almacenar la información, y otro que se utiliza para acceder a ella. Al aplicar esta solución, se obtiene una estructura poco resiliente al cambio. Por ejemplo, si se modifican los cálculos para obtener el resultado deseado, es necesario modificar también la implementación del módulo, lo que da lugar a la posible introducción de errores. Asimismo, la manera de transmitir la información relacionada con la interrupción puede variar debido a modificaciones en el hardware (tipo o modelo del sensor, componentes mecánicos, etc.). En \gls{IS}, decimos que el módulo oculta más de un ítem de cambio y, como vimos previamente, esto no se ajusta a las prácticas recomendadas.

Además, en muchos casos ni siquiera se construye este módulo, sino que cada cliente del dispositivo se encarga de capturar y procesar los datos provenientes, lo que provoca que, ante cualquier cambio, deba modificarse el código en diferentes módulos a lo largo del sistema.

Es debido a las problemáticas mencionadas que resulta útil contar con una forma general de abordar este problema desde el punto de vista del diseño orientado al cambio. Para ello, tomaremos como referencia el trabajo realizado sobre el robot desmalezador en \cite{paperPomponio}, en el cual se empleó la estructura modular presentada en la Figura \ref{activo}, destinada a llevar a cabo las actividades necesarias para el uso de sensores que generan interrupciones en el sistema. Replicaremos esta estructura, siguiendola casi como si fuera un patrón de diseño.

\begin{figure}[H]
\caption{Estructura componentes para la lectura de un sensor activo.}
\label{activo}
\centering
\begin{tikzpicture}\hypertarget{fig:ConnectBufferToMCU}{}
%-------------Estilos para dibujar-----
\tikzstyle{módulo}=[minimum width=1cm,inner sep=2mm,above right,draw,align=center,minimum width=2cm, font=\bfseries]

\tikzstyle{supest}=[rounded corners=1.5mm, minimum width=2cm,inner sep=2mm,draw,text width=2cm]

\tikzstyle{componente}=[minimum width=2cm,inner sep=2mm,draw,text width=2cm]

\tikzstyle{nombre}=[inner sep=0mm, font=\bfseries]

\tikzstyle{pipe}=[-latex,thick,line width=4pt]

\tikzstyle{modExt}=[minimum width=1cm,inner sep=2mm,above right,draw, dotted,line width=2pt,align=center,minimum width=2cm,color=gray, font=\bfseries]

\tikzstyle{flechaFisica}=[-latex,snake=coil,segment aspect=0, red, thick];
%--------------------------

\node[módulo,fill=yellow!20](Pin){Dispositivo};

\node[módulo, above left=0.5cm and 2cm of Pin, fill=yellow!20](CountTime){Comando};

\draw[flechaFisica](Pin) -| (CountTime);

\node[módulo, above=1cm of CountTime, fill=yellow!20](CRpinCollector){Colector};

\draw[-latex](CountTime) edge (CRpinCollector);

\node[módulo, left=1cm of CRpinCollector, fill=yellow!20](CRBuffer){Computador};

\draw[-latex](CRBuffer) edge (CRpinCollector);

\node[módulo, below=5cm of CRBuffer, fill=yellow!20](BufferReader){Cliente};

\draw[-latex](BufferReader) edge (CRBuffer);

\node[nombre, below right = 1cm and -3cm of Pin, fill=yellow!20](ConnectBufferToMCU){};

\node[componente, fit=(Pin)(CountTime)(CRBuffer)(ConnectBufferToMCU)]{};

%%------------------------------Referencias------------

\node[módulo, below left=1cm and 1cm of BufferReader, fill=yellow!20](mod){nombre};
\node[right =0.5cm of mod](modDesc){módulo};

\node[right=4cm of modDesc](x1){};
\node[right=2cm of x1](x2){};
\draw[-latex](x1)--(x2);
\node[right=0.3cm of x2](llp){llamada a procedimiento};

\node[below=0.5cm of mod.south west](x1a){};
\node[below=0.5cm of mod.south east](x2a){};
\draw[flechaFisica](x1a)--(x2a);
\node[below right=-0.4cm and 0.3cm of x2a, text width=4cm](hand){llamada a procedimiento a partir de una interrupción física (handler)};

%
\node[supest, fit=(mod)(hand)(llp)]{};

\end{tikzpicture}
\label{fig:ConnectBufferToMCU}
\end{figure}

\declareCMod{Dispositivo}
\declareCMod{Colector}
\declareCMod{Computador}
\declareCMod{Comando}

En esta estructura se distinguen cuatro módulos principales: \Dispositivo, que encapsula el hardware asociado al dispositivo encargado de generar e introducir la interrupción. Este módulo cuenta con un manejador de interrupción configurado para invocar al comando encapsulado en el módulo \Comando cuando la interrupción es lanzada. Este último sigue el patrón de diseño \textit{Command} y ejecuta los métodos del módulo \Colector para registrar la información requerida sobre la interrupción (por ejemplo, el momento exacto en que ocurrió el evento o la cantidad de veces que sucedió). De este modo, podemos deducir que \Colector almacena la información ``cruda'' proveniente de la interrupción o del sensor. Finalmente, se encuentra el módulo \Computador, encargado de procesar la información cuando esta es solicitada. Para ello, lee los valores almacenados en \Colector y aplica cálculos o algoritmos que computan la información final aportada por el dispositivo. Un ejemplo de ello podría ser el cálculo de la velocidad de rotación de una rueda o la obtención de los inputs de un joystick.

A continuación se presenta un ejemplo de aplicación con el objetivo de analizar en mayor profundidad la estructura modular. Se considera un sensor de efecto \gls{hall} montado de manera tal que, al girar una rueda, imanes permanentes pasen cerca de este. De esta forma, el sensor puede utilizarse para medir la velocidad de rotación. En la Figura \ref{hall} se observa la variación de voltaje producida por el paso de los imanes frente al sensor. Cada vez que el dispositivo detecta un campo magnético, emite una interrupción que es gestionada por el módulo \Comando, el cual actúa como un comando y, por lo tanto, conoce qué funciones ejecutar dentro del módulo \Colector.

\begin{figure}[H]
    
    \caption{Ejemplo de la variación de voltaje producida por un sensor de efecto Hall al detectar un cambio del campo magnético. Cada pico de voltaje provoca que el microcontrolador genere una interrupción. Imagen extraída de \cite{disenioViejo2}.}
    \centering
    \includegraphics[width=0.8\linewidth]{sensorHall.png}
    \label{hall}
\end{figure}

\declareCMod{SensorVelocidad}

En la Figura \ref{estructuraHall} se presenta la estructura de módulos de esta solución, junto con pseudocódigo que ilustra una posible implementación.

Con los imanes colocados a una distancia conocida, para calcular la velocidad es necesario registrar los dos últimos instantes de tiempo en que fueron detectados. De forma simplificada, la velocidad se obtendrá al dividir la distancia entre los imanes por el tiempo transcurrido entre ambas detecciones. En consecuencia, el módulo \Colector debe proveer un método para almacenar el momento de cada detección. Posteriormente, el módulo \SensorVelocidad, que cumple la función de \Computador, tomará la información almacenada en \Colector y realizará el cálculo matemático para determinar la velocidad de giro de la rueda. Los cálculos, que pueden ser complejos, se ejecutarán únicamente bajo demanda, es decir, cuando el cliente lo requiera. Esto permite optimizar el rendimiento del sistema al disminuir la carga computacional necesaria. Cabe aclarar que este ejemplo está simplificado y omite situaciones que conllevarían una complejidad innecesaria.

\begin{figure}[H]
\caption{Ejemplo módulos para obtener la información referida a la velocidad.}
\label{estructuraHall}
\begin{center}
\scalebox{.90}{
\begin{tikzpicture}\sf

\umlclass[]{SensorHall}
{}
{
start()\\
stop()\\
signalHandler() \\
setCommand(i: Command)
}

\umlnote[above=1cm of SensorHall,width=3cm]{SensorHall}
{
signalHandler() \{\\
\ \ \ \ cmd.execute() \\
\}
}

\umlclass[above left=1cm and 2cm of SensorHall]{Count}
{}
{
execute() \\
}

\umlnote[below left=2.5cm and -1cm of Count,width=4cm]{Count}
{
Hereda de Command \\
execute() \{ \\
\ \ \ colector.addEvent() \\
\}
}

\umlclass[above=1cm of Count]{Colector}
{}
{
addEventTime() \\
getLastEventTime() \\
getSecondLastEventTime() \\
}

\umlclass[left=2cm of Colector]{SensorVelocidad}
{
Buffer(i: Collector)
}
{
getVelocidad()
}

\umlnote[below=1cm of SensorVelocidad,width=8cm]{SensorVelocidad}
{
getVelocidad() \{ \\
\ \ \ last = colector.getLastEventTime() \\
\ \ \ second = colector.getSecondLastEventTime() \\
\ \ \ return DISTANCIA / (last - second) \\
\}
}

\umlnote[right=1cm of Colector,width=5.5cm]{Colector}
{
addEventTime() \{ \\
\ \ \ secondLast = last \\
\ \ \ last = time.getCurrentTime() \\
\}

}

\umluniaggreg{SensorVelocidad}{Colector}
\umluniaggreg[geometry=-|]{SensorHall}{Count}

\end{tikzpicture}
}
\end{center}
\end{figure}

Al aplicar esta solución orientada al cambio, preparamos esta sección del sistema para cambios probables, tanto de hardware como de algoritmos. Además, las responsabilidades se separan en módulos independientes, logrando que una modificación en uno de ellos no afecte al resto del sistema. De este modo, si la rueda fuera modificada y cambiara la distancia entre los imanes, bastaría con actualizar la implementación del módulo \SensorVelocidad. A su vez, si el sensor \gls{hall} fuese reemplazado, solo se cambiaría el módulo que lo encapsula, manteniendo intacto el resto de la aplicación.

En esencia, las ventajas obtenidas con este diseño impactan directamente en la sostenibilidad y el ciclo de vida del software. Al lograr este nivel de bajo acoplamiento y alta cohesión, se minimiza el costo y el riesgo asociados al mantenimiento, ya que los cambios quedan confinados y son esperados. Esto no solo previene la propagación de errores, sino que genera que el sistema tenga una alta resiliencia y flexibilidad.


\subsubsection*{Recolectar información de manera periódica.}

Algunos sistemas se encargan de mostrar, almacenar o verificar la información de los sensores a intervalos regulares. En estos casos no resulta crítico perder valores intermedios, es decir, no se requiere una respuesta inmediata. Un ejemplo de ello puede ser una estación meteorológica o un dispositivo médico de monitorización, como un tensiómetro que registra los valores de presión del paciente cada cierto período.

Una implementación intuitiva consiste en escribir un \textit{loop} en el que se verifique la información de los sensores, llamando a métodos que la obtengan directamente del hardware, para luego ejecutar una función \textit{sleep} que bloquea el programa durante un tiempo determinado. Este enfoque presenta varias desventajas: en primer lugar, el tiempo de ejecución de la propia rutina alarga el período; en segundo lugar, si se desean agregar otras funcionalidades durante la espera, es necesario dividir la llamada a \textit{sleep} y recalcular los tiempos de ejecución.

Una solución más adecuada desde el punto de vista del diseño orientado al cambio es la siguiente: se configura un temporizador para que, cada \textit{x} cantidad de tiempo, genere una interrupción. Esta es una funcionalidad provista por muchos entornos de desarrollo para sistemas embebidos, como \gls{arduino}.
Para dicha interrupción, se registrará un \textit{handler} que consistirá en un módulo implementado según el patrón de diseño \textit{Command} (ver Sección \ref{patronCommand} para mas información sobre este tipo de aplicación del patrón). Este encapsula las funciones que deben ejecutarse para llevar a cabo la funcionalidad deseada como, por ejemplo, solicitar la información a sus respectivos módulos \Computador o a los sensores en sí, para luego registrarla en un cierto módulo que oculte la estructura de datos. De esta forma, se logra liberar al procesador durante los tiempos de espera y desacoplar esta funcionalidad.


\section{Máquinas de estado}\label{cap:state}

Muchos sistemas ajustan su comportamiento durante su ejecución en función de diversas causas, como interacciones con el entorno o requisitos internos. Un ejemplo sencillo es un sistema de control de microondas, que no iniciará el calentamiento si la puerta está abierta. En este caso, la condición de la puerta representa un estado interno que restringe un comportamiento (calentar) mientras permite otro. Del mismo modo, el comportamiento de un motor en un robot está determinado por su estado de dirección, que puede ser ``giro horario'' o ``giro antihorario''. Otro ejemplo es un sistema en el que, al finalizar una operación, se cambia del estado trabajando al estado esperando, lo que también altera el comportamiento del sistema. De manera similar, un sistema de climatización puede estar en estado calentando o enfriando, dependiendo de la configuración del termostato. Por lo tanto, la gestión de estados, sus transiciones y los cambios de comportamiento asociados a estos son aspectos fundamentales en el diseño de sistemas complejos y representan un item de cambio bastante probable.

Una solución de implementación tradicional para gestionar estados consiste en almacenarlos en una variable. Posteriormente, se verifica el valor de esta variable para modificar el comportamiento de las funciones, como se ilustra en el código \ref{codigoMicro}.

\begin{lstlisting}[label=codigoMicro,caption={Ejemplo de manejo de estados tradicional, en el caso del microondas.}]
calentar():
    if (estado == PuertaAbierta):
        return
    else if (estado == Preparado):
        magnetron.encender()
    else if (estado == Pausa):
    	magnetron.encender()

\end{lstlisting}

Este enfoque, si bien es directo, presenta varias desventajas al modificar o extender el código. Por ejemplo, al agregar nuevos estados o cambiar el comportamiento del sistema, la gestión se vuelve rápidamente compleja. Esta creciente complejidad es una de las principales desventajas de su implementación. A medida que se añaden más estados, cada método requiere más verificaciones, lo que conduce a una proliferación de estructuras \textit{if-else}. Esto no solo dificulta la lectura del código, sino que también aumenta la probabilidad de introducir errores, ya que cada nuevo estado debe ser cuidadosamente incorporado y verificado en todas las partes relevantes del sistema. Además, este enfoque compromete la sostenibilidad del software. En el Código \ref{nuevoEstado} se muestra cómo se agrega un nuevo estado al método \verb|calentar()|.

\begin{lstlisting}[label=nuevoEstado,caption={Ejemplo de introducción de un nuevo estado a la solución tradicional.}]
calentar():
    if (estado == PuertaAbierta):
        return
    else if (estado == Preparado):
        magnetron.encender()
    else if (estado == Pausa):
    	magnetron.encender()
    else if (estado == Calentando):
    	magnetron.apagar()

\end{lstlisting}

Cuando el comportamiento de un estado debe cambiar, es posible que se necesiten modificaciones en múltiples métodos. Esto puede llevar a la duplicación de código o dificultar la identificación de las partes que requieren cambios, complicando el proceso y aumentando el riesgo de errores. 

Otra desventaja clave es la baja modularidad, ya que el comportamiento asociado a cada estado no está claramente delimitado. Si cada estado requiere comportamientos complejos, el código se vuelve monolítico y difícil de extender sin alterar los métodos existentes. Por ejemplo, al agregar un estado ``EnPausa'', sería necesario modificar la lógica de múltiples métodos para verificar este nuevo estado y ajustar el comportamiento de manera apropiada. Todas estas deficiencias dificultan la reutilización del código y hacen que la verificación del correcto funcionamiento del sistema sea cada vez más compleja.

Este tipo de solución es ampliamente utilizado. Un ejemplo relevante se encuentra en el software original del robot desmalezador, como se describe en el informe \cite{informe1}. En particular, se definen diferentes estados de operación del robot y se utiliza una gran estructura de control \textit{switch-case} dentro del bucle principal. Esta estructura decide la acción a ejecutar en función del estado actual, como se detalla en el Código \ref{codigoLoopMain}.

\begin{lstlisting}[caption=Main loop del previo firmware del robot desmalezador \cite{informe1}, label={codigoLoopMain}]
switch (ESTADO) {
	case DUTY_REMOTO:
		duty_remoto();
		break;
	case RPM_REMOTO:
		rpm_remoto();
		break;
	case DUTY_PC:
		duty_pc();
		break;
	case RPM_PC:
		rpm_pc();
		break;	
	case CALIBRACION:
		calibracion();
		break;
	case PERDIDA_SENAL:
		perdida_senal();
		break;
	case EMERGENCIA:
		EMERGENCY();
		break;
	default:
		ESTADO = PERDIDA_SENAL;
		break;
}
\end{lstlisting}

Antes de abordar una perspectiva de diseño para gestionar el cambio, se analizará en detalle el ejemplo presentado en el libro de Douglass \cite{douglass} y la aplicación de una otra solución al manejo de estados.

El ejemplo propuesto consiste en el sistema de control de un microondas. Para representar el comportamiento del mismo, el autor presenta una máquina de estados como la de la Figura \ref{maquinaMicroondas}. Aunque contiene algunas incoherencias y no es del todo exacta, es suficiente para el propósito del ejemplo que se busca exponer.

\begin{figure}[h]
\caption{Máquina de estados extraída del libro \cite{douglass}.}
\label{maquinaMicroondas}
\begin{center}
\begin{tikzpicture}

\umlsimpleclass[fill=red!20, x=-3]{Apagado}
\umlsimpleclass[fill=red!20, x=3]{Preparado}
\umlsimpleclass[fill=red!20, x=-3, y=-3]{PuertaAbierta}
\umlsimpleclass[fill=red!20, x=3, y=-3]{Calentando}
\umlsimpleclass[fill=red!20, x=0, y=-6]{Pausa}

\umltrans[arg=prender, pos=0.5] {Apagado}{Preparado}
\umltrans[arg=cancelar, pos=1.5, geometry=|-|, anchor2=-150] {PuertaAbierta}{Preparado}
\umltrans[arg=calentarTemp, anchor1=-30, anchor2=30, pos=0.3] {Preparado}{Calentando}
\umltrans[arg=tempListo, pos=0.3] {Calentando}{Preparado}
\umltrans[arg=cerrar, pos=0.5,anchor1=8, anchor2=170] {PuertaAbierta}{Calentando}
\umltrans[arg=abrir, pos=0.5,anchor1=-170, anchor2=-8] {Calentando}{PuertaAbierta}
\umltrans[arg=abrir, pos=1.2,geometry=-|] {Pausa}{PuertaAbierta}
\umltrans[arg=reanudar, pos=1.3,geometry=-|,anchor1=13, anchor2=-130] {Pausa}{Calentando}
\umltrans[arg=pausar, pos=0.7,geometry=|-,anchor1=-30, anchor2=0] {Calentando}{Pausa}
\umltrans[arg=cancelar, pos=1.3,anchor1=-13,anchor2=13,arm1=7cm,geometry=-|-]{Pausa}{Preparado}
\umltrans[arg=cancelar, pos=1.4,arm1=4cm,anchor2=-10,geometry=-|-]{Calentando}{Preparado}


\end{tikzpicture}
\end{center}
\end{figure}

El funcionamiento principal del sistema se representa mediante estados y transiciones, donde cada transición implica un comportamiento específico relacionado con la salida del estado actual y la entrada al siguiente. Por ejemplo, si el sistema se encuentra en el estado \textit{PuertaAbierta} y se recibe el evento \textit{puertaCerrada}, se realizará una transición al estado \textit{Calentando}. Durante este proceso, el magnetrón será activado para emitir las ondas necesarias que calentarán la comida.

A simple vista parece un comportamiento complejo y eso que solo es un ejemplo simplificado, por lo que en la vida real los casos pueden ser mucho más extensos. Este es uno de los motivos por los cuales es útil contar con un buen diseño. El desarrollador debe tener en cuenta que sea fácil modificar las transiciones y también agregar y quitar estados.

En \cite{douglass}, el autor construye un módulo encargado de mantener el estado, el cual sabe qué funciones ejecutar cuando se da una transición. Esto es, recibe el evento, verifica si corresponde a un cambio de estado y de ser así ejecuta el método de ``salida'' del estado actual, ejecuta el método de ``entrada'' del nuevo estado y actualiza el valor del estado actual. Además, propone una implementación utilizando una tabla bidimensional lo cual lo hace un sistema eficiente computacionalmente hablando. En el caso de querer modificar estados, agregarlos o quitarlo es necesario cambiar la implementación de este módulo. 

\begin{lstlisting}[caption=Código ejemplo Douglass State Table, label={ifsanidados}]
void TokenizerStateTable_eventDispatch(TokenizerStateTable* const me, Event e) {
int takeTransition = 0;
Mutex_lock(me->itsMutex);
/* first ensure the entry is within the table boundaries */
  if (me->stateID >= NULL_STATE && me->stateID <= GN_PROCESSINGFRACTIONALPART_STATE) {
    if (e.eType >= EVDIGIT && e.eType <= EVENDOFSTRING) {
      /* is there a valid transition for the current state and event? */
      if (me->table[me->stateID][e.eType].newState != NULL_STATE) {
        /* is there a guard? */
        if (me->table[me->stateID][e.eType].guardPtr == NULL)
          /* is the guard TRUE? */
          takeTransition = TRUE; /* if no guard, then it "evaluates" to TRUE */
        else
          takeTransition =(me->table[me->stateID][e.eType].guardPtr(me));
        if (takeTransition) {
          if (me->table[me->stateID][e.eType].exitActionPtr != NULL)
            if (me->table[me->stateID][e.eType].exitActionPtr->nParams == 0)
              me->table[me->stateID][e.eType].exitActionPtr->aPtr.a0(me);
            else
              me->table[me->stateID][e.eType].exitActionPtr->aPtr.a1(me, e.ed.c);
          if (me->table[me->stateID][e.eType].transActionPtr != NULL)
            if (me->table[me->stateID][e.eType].transActionPtr->nParams == 0)
              me->table[me->stateID][e.eType].transActionPtr->aPtr.a0(me);
            else
              me->table[me->stateID][e.eType].transActionPtr->aPtr.a1(me, e.ed.c);
          if (me->table[me->stateID][e.eType].entryActionPtr != NULL)
            if (me->table[me->stateID][e.eType].entryActionPtr->nParams == 0)
              me->table[me->stateID][e.eType].entryActionPtr->aPtr.a0(me);
            else
              me->table[me->stateID][e.eType].entryActionPtr->aPtr.a1(me, e.ed.c);
          me->stateID = me->table[me->stateID][e.eType].newState;
        }
      }
    }
  }

Mutex_release(me->itsMutex);
}
\end{lstlisting}


En el Código \ref{ifsanidados} se presenta la implementación de uno de los métodos fundamentales de la solución propuesta en el libro. Aunque este enfoque cumple con la gestión de estados, el código no es legible y además no parece seguir buenas prácticas de diseño, ya que utiliza al menos cuatro niveles de sentencias if anidadas. Esto no solo complejiza su entendimiento, sino que también dificulta futuras modificaciones. Por otro lado, dado que las estructuras de datos son un elemento común de cambio en el desarrollo de software, las interfaces deben diseñarse para ser lo más independientes posible de la estructura de datos que se utiliza para implementarlas. Al no considerar esta independencia, cualquier cambio en una de ellas puede repercutir en todo el sistema, lo que aumenta la probabilidad de introducir errores y la necesidad de una reverificación exhaustiva.

Como un enfoque preparado para el cambio se propone el uso del patrón \textit{State} de Gamma \cite{anexoState}. Con ciertos ajustes, este patrón permite que los estados realicen transiciones de forma autónoma. Básicamente, el patrón establece la creación de un módulo por cada estado del sistema, con el objetivo de ajustar la implementación al comportamiento que corresponde a dicho estado. Esto permite una transición dinámica entre estados, ya que el cambio de estado está representado por el cambio de módulo.

El patrón admite distintas opciones para gestionar la transición entre estados. En este caso, para permitir que cada estado transicione de manera independiente, se añade una referencia a los posibles estados siguientes. De esta forma, si se recibe el evento adecuado, un estado puede invocar el método para cambiar de estado, pasando la referencia del nuevo. Por lo tanto, el constructor de cada estado debe incluir como argumento una referencia a cada uno de sus posibles estados siguientes.

Este uso del patrón \textit{State} también es propuesto en \cite[\textit{Chapter 10 : Finite State Machine Patterns Part III: New Patterns as Design Components}]{douglass}.

Para aplicar el patrón al ejemplo extraído del libro\cite{douglass}, se debe seguir el siguiente procedimiento. En primer lugar, se crea un módulo que contenga un método para manejar cada evento y que, a su vez, delegue dicha gestión al estado actual. Posteriormente, se define un módulo que defina el estado del cual heredarán todos los estados concretos del sistema. En este caso, se creará un módulo por cada estado que se muestra en la máquina de estados de la Figura \ref{maquinaMicroondas}. En la Figura \ref{participantesState} podemos observar la estructura obtenida junto a seudocódigo que describen una posible implementación a modo de guía.

\begin{figure}[h!]
\caption{Módulos participantes del patrón state en el ejemplo del horno microondas.}
\label{participantesState}
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}\sf
\umlclass[]{Microondas}
{}
{
prender() \\
cancelar() \\
cerrar() \\
abrir() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
cambiarEstado(i: Estado)\\
}

\umlclass[right=1cm of Microondas,type=abstract]{EstadoMicroondas}
{}
{
\umlvirt{prender(i: Microondas)} \\
\umlvirt{cancelar(i: Microondas)} \\
\umlvirt{abrir(i: Microondas)} \\
\umlvirt{cerrar(i: Microondas)} \\
\umlvirt{reanudar(i: Microondas)} \\
\umlvirt{calentarTemp(i: Microondas)} \\
\umlvirt{tempListo(i: Microondas)} \\
\umlvirt{pausar(i: Microondas)} \\
}

\umlclass[below right=3cm and 2.2cm of EstadoMicroondas]{Apagado}
{
Apagado(i: Preparado)
}
{
prender(i: Microondas) \\
cancelar(i: Microondas) \\
.\\
.\\
.\\
}


\umlclass[below left=3cm and 7cm of EstadoMicroondas]{Preparado}
{
Preparado(i: Calentando)
}
{
prender(i: Microondas) \\
cancelar(i: Microondas) \\
.\\
.\\
.\\
}

\umlclass[below left=3cm and 1.6cm of EstadoMicroondas]{PuertaAbierta}
{
PuertaAbierta(i: Calentando,\\ i: Preparado)
}
{
prender(i: Microondas) \\
cancelar(i: Microondas) \\
.\\
.\\
.\\
}

\umlclass[below left=3cm and -3cm of EstadoMicroondas]{Calentando}
{
Calentando(i: PuertaAbierta,\\ i: Pausa)
}
{
prender(i: Microondas) \\
cancelar(i: Microondas) \\
.\\
.\\
.\\
}

\umlclass[below right=3cm and -2.3cm of EstadoMicroondas]{Pausa}
{
Pausa(i: Calentando,\\ i: PuertaAbierta)
}
{
prender(i: Microondas) \\
cancelar(i: Microondas) \\
.\\
.\\
.\\
}

\umlinherit[geometry=|-|, arm1=3.75cm]{Preparado}{EstadoMicroondas}
\umlinherit[geometry=|-|, arm1=4cm]{PuertaAbierta}{EstadoMicroondas}
\umlinherit[arm1=4cm,anchor1=84]{Calentando}{EstadoMicroondas}\umlinherit[geometry=|-|, arm1=4cm]{Pausa}{EstadoMicroondas}
\umlinherit[geometry=|-|, arm1=3.802cm]{Apagado}{EstadoMicroondas}
\umluniaggreg{Microondas}{EstadoMicroondas}

\umlnote[below=1cm of PuertaAbierta,width=3cm]{PuertaAbierta}{
calentarTemp()\{ \\
\ \ \ \ return \\
\}
}

\umlnote[left=1cm of Microondas,width=4.5cm]{Microondas}{
prender()\{ \\
\ \ \ \ this.estado.prender(this) \\
\}\\
\\
cambiarEstado(Estado e)\{ \\
\ \ \ \ this.estado = e \\
\}
}

\umlnote[above=3cm of Apagado,width=5.5cm]{Apagado}{
Apagado(Preparado st)\{ \\
\ \ \ \ this.stPrep = st \\
\}\\
\\
prender(Microondas m)\{ \\
\ \ \ \ ... \\
\ \ \ \ encender microondas \\
\ \ \ \ ... \\
\ \ \ \ m.cambiarEstado(this.stPrep) \\
\}
}

\end{tikzpicture}
}
\end{center}

\end{figure}
\declareCMod{Microondas}
\declareCMod{Calentando}
\declareCMod{PuertaAbierta}

Siguiendo esta estructura modular, el módulo \Microondas provee un método para cada evento existente. De esta forma, cuando un método es invocado, delega la funcionalidad al estado actual, lo que permite modificar el comportamiento del microondas según su estado. Un ejemplo de cómo implementar este proceso se presenta en el Código \ref{ejemploReanudar}. Es necesario pasar una referencia del \Microondas a cada método del estado para permitir la transición entre estados. Una posible implementación de este comportamiento se observa en el Código \ref{cambioDeEstado}, donde el módulo \Calentando apaga el magnetrón para proteger al usuario y luego transiciona al estado \PuertaAbierta. Para realizar este cambio, el módulo \Calentando necesita una referencia a \PuertaAbierta, la cual fue almacenada previamente al ser pasada como argumento en su constructor.

\begin{lstlisting}[caption=Ejemplo de implementación método reaundar del módulo Microondas, label=ejemploReanudar]
reaundar(){
    this.estado.reanudar(this)
}
\end{lstlisting}
\begin{lstlisting}[caption=Ejemplo de implementación método abrir del módulo Calentando, label=cambioDeEstado]
abrir(Microondas m){
	...
	magnetron.apagar()
  m.cambiarEstado(this.stPuertaAbierta)
}
\end{lstlisting}

Cuando el microondas se encuentra en un estado que no admite un evento específico, el sistema puede simplemente no realizar ninguna acción. Por ejemplo, en el estado \PuertaAbierta, el evento \textit{calentar} no puede desencadenar ningun comportamiento. En este caso, no se cumplen las condiciones para encender el magnetrón y calentar la comida. Por lo tanto, el evento es ignorado, lo cual puede implementarse como se muestra en el Código \ref{calentarPuerta}.
\begin{lstlisting}[caption=Ejemplo de implementación método calentar del módulo PuertaAbierta, label=calentarPuerta]
calentar(Microondas m){
	return
}
\end{lstlisting}

Como se explicó en la sección \nameref{secDocumentacion}, cada aplicación de un patrón de diseño debe ser acompañada de su correspondiente documentación. En este caso, podemos observarla en la Figura \ref{docState} en la misma se establece qué módulo cumple la función de cada participante, los cambios previstos y la justificación de su aplicación.

\begin{figure}
\caption{Documentación de la aplicación del patrón \textit{State} para el manejo de los estados del microondas.}
\label{docState}
\begin{pattern}[]{Estados del microondas}{Algorithm}{idFigAlg}
\based{Estado (State)}
\why{\textbf{Cambios previstos}: En base a su estado, el microondas responde de diversas maneras a distintos eventos. Es posible modificar, agregar o eliminar estados.

\textbf{Funcionalidad}: Cada método del módulo Microondas es un handler para un evento particular. La respuesta del sistema ante los eventos cambia en base al estado actual del mismo. Ademas, los eventos pueden desencadenar cambios de estado durante la ejecución de su handler.
}
\assigns
\is{Microondas}{Contexto}
\is{EstadoMicroondas}{Estado}
\is{Preparado}{EstadoConcreto}
\is{PuertaAbierta}{EstadoConcreto}
\is{Calentando}{EstadoConcreto}
\is{Pausa}{EstadoConcreto}
\is{Apagado}{EstadoConcreto}

\end{pattern}
\end{figure}


Aplicando este patrón para el manejo de estados, se logra una solución más elegante y escalable para manejarlos, superando muchas de las limitaciones del enfoque basado en verificaciones de estado dentro de cada método.

\declareCMod{Descongelando}
\declareCMod{EstadoMicroondas}

El uso de este patrón mejora significativamente la legibilidad y modularidad del código. En lugar de manejar el comportamiento de todos los estados en una misma función, cada estado tiene su propio módulo. Esto permite que el código esté mejor organizado y sea más fácil de entender, ya que cada módulo encapsula el comportamiento específico de su estado, eliminando la necesidad de múltiples verificaciones condicionales y simplificando el flujo de ejecución.

Otro beneficio importante es que facilita la \textbf{adición de nuevos estados}. Cuando se necesita agregar un nuevo estado, como \textit{Descongelando} (similar a \textit{Calentando}, pero con un ciclo de encendido y apagado del magnetrón), solo se debe definir un nuevo módulo homónimo que herede de \EstadoMicroondas. No es necesario modificar la implementación de ningún otro estado, ya que la nueva funcionalidad es independiente. De todas formas, este nuevo módulo debe ser añadido a los constructores de los estados que puedan precederlo. Esta facilidad hace que el sistema sea mucho más flexible y escalable a medida que aumenta su complejidad.

Además, el \textit{State} elimina la duplicación de código, ya que cada módulo de estado gestiona su propio comportamiento. En el enfoque tradicional, muchos métodos deben realizar repetidas verificaciones del estado y aplicar el comportamiento adecuado, lo que conduce a código duplicado y potencialmente inconsistente.

Una ventaja clave es que permite cambiar el comportamiento del sistema dinámicamente. A medida que el estado cambia, el comportamiento del módulo principal también cambia dinamicamente. 

Todo esto hace que el sistema sea más robusto y adaptable. Cuando es necesario modificar el comportamiento de un estado, simplemente se actualiza la implementación del módulo correspondiente, lo que facilita la localización y modificación del código relevante. Y como resultado es más fácil de mantener y reduce el riesgo de introducir errores al cambiar o extender el sistema.

Existen otros casos de usos del patrón, como en los ejemplos que se verán más adelante, puede ser usado para cambiar el comportamiento de cierta parte del sistema o a modo de configuración del mismo. El concepto principal es el mismo, crear un módulo por cada estado posible y cambiar la implementación para que se ajuste a lo requerido.

\section{Control anti-rebote}
Muchos dispositivos de entrada para sistemas embebidos utilizan contacto metal con metal para indicar eventos de interés, como botones, interruptores y relés. A medida que el metal entra en contacto, se produce una deformación física que resulta en un contacto intermitente de las superficies. Esto genera señales que de no ser filtradas pueden causar una lectura errónea. 

En el libro de Douglass \cite{douglass} encontramos una propuesta de solución más cerca de la implementación que del diseño, algo así como un patron idiomático. Esta consiste en utilizar un temporizador para permitir un tiempo de gracia antes de confirmar una transición en el estado. Esto es, al percibir un cambio en la entrada se inicia el \textit{timer} y se confirma el cambio de estado solo si el valor de la entrada sigue siendo distinto que antes de percibir la modificación. 

\begin{lstlisting}[caption=Código ejemplo de una estrategia de deteccion de rebote extraído de \cite{douglass}.,label=deboun]
void ButtonDriver_eventReceive(ButtonDriver* const me) {
    Timer_delay(me->itsTimer, DEBOUNCE_TIME);
    if (Button_getState(me->itsButton) != me->oldState) {
        /* must be a valid button event */
        
        me->oldState = me->itsButton->deviceState;
        
        if (!me->oldState) {
            
            /* must be a button release, so update toggle value */
            if (me->toggleOn) {
                me->toggleOn = 0; /* toggle it off */
                Button_backlight(me->itsButton, 0);
                MicrowaveEmitter_stopEmitting(me->itsMicrowaveEmitter);
            }
            else {
                me->toggleOn = 1; /* toggle it on */
                Button_backlight(me->itsButton, 1);
                MicrowaveEmitter_startEmitting(me->itsMicrowaveEmitter);
            }
        }
        /* if it’s not a button release, then it must
        be a button push, which we ignore.
        */
    }
}
\end{lstlisting}

Desde el punto de vista de la \gls{IS}, podemos decir que se están combinando múltiples responsabilidades en un mismo módulo, lo cual dificulta el diseño orientado al cambio. El estado y la decisión de transicionar son responsabilidad de un solo módulo, lo que podría generar inconvenientes si se desea modificar el criterio de aceptación de la señal. Esto se evidencia en el código de ejemplo \ref{deboun}, donde encontramos múltiples sentencias \textit{if} anidadas, que, como ya se ha visto, no son un buen indicio. Por otro lado, al ocultar varias responsabilidades en un mismo módulo, se obtiene un software rígido a los cambios, donde cualquier modificación requiere editar la implementación. Esto, a su vez, puede generar la introducción de nuevos errores y la necesidad de volver a verificar el trabajo realizado.

Una solución que se ajusta más a los principios de la \gls{IS} busca separar los puntos de cambio en módulos diferentes. En este caso, tenemos dos conceptos principales: el estado, por ejemplo, \textit{on} o \textit{of}, y el criterio de aceptación de la transición. Para el primer concepto, podemos utilizar el patrón de diseño \textit{State} \ref{anexoState} de Gamma, como vimos en el capítulo \ref{cap:state}. Para el segundo, podemos emplear otro patrón de Gamma, el \textit{Strategy} \ref{anexoStrategy}, que nos permite prepararnos para un cambio en el algoritmo de decisión.




\section{Verificación de precondiciones.}
El autor del libro \cite{douglass} comenta que uno de los problemas más grandes que observa en el desarrollo de sistemas embebidos es que muchas funciones tiene precondiciones para ejecutarse correctamente pero que rara vez se verifica que todas se cumplan. Además, el procedimiento común de informar precondiciones inadecuadas en una función en \textbf{C}\footnote{Lenguaje de programación comúnmente utilizado en sistemas embebidos.} es a traves del valor de retorno (-1 en caso de errores, 0 en el contrario). Por lo tanto, el encargado de manejar el error es la función que invocó a la segunda, generando así un acoplamiento extra en el código. Esto provoca una complicación que muchas veces deriva en un mal manejo de los errores. Por ejemplo, supongamos que se tiene un módulo que exporta una función que permite guardar un valor, \verb|setValor(i: Valor)|. Existen múltiples posibles implementaciones, estas son algunas:
\begin{itemize}
    \item Una posible implementación, consiste en que la función no realice ninguna verificación y simplemente guarde en una variable el valor pasado como argumento. Esto puede generar un error en el momento si el tipo no coincide o en el futuro, si el valor está por fuera de ciertos parámetros requeridos por el sistema. Por ejemplo, si se está almacenando un entero negativo pero algún función requiere como precondición que siempre sea positivo, se puede provocar un error en el futuro. Por otro lado, esta implementación obliga a que todos las funciones que usen este valor deban verificar que sea positivo. Escribiendo código repetido y que en caso de que el requisito cambie deba ser actualizado manualmente.
    \item Otra, se basa en verificar si el valor es permitido, haciendo que la función retorne un valor inidicando el resultado de la validación, 0 en caso afirmativo o -1 en caso contrario. Este enfoque es mejor que no realizar manejo alguno, pero como se comentó en el principio, se está acoplando al usuario de la función con el módulo que la exporta, ya que este tiene que verificar el valor de retorno para determinar si existió un error o no.
\end{itemize}

La solución que se propone en el libro es una combinación de patrón y practica de programación, tiene los siguientes conceptos claves:

\begin{itemize}
    \item Construir tipos de auto-verificación siempre que sea posible.
    \item Verificar los valores de los parámetros entrantes para un rango adecuado.
    \item Verificar la consistencia y razonabilidad entre uno o un conjunto de parámetros.
\end{itemize}

No se ha planteado una solución de diseño general o un patrón, pero desde la \gls{IS} podemos ayudar a preparar el sistema para el cambio y, a la vez, realizar las verificaciones necesarias. Para ello, proponemos la aplicación del patrón \textit{Decorator} \ref{anexoDecorator} de Gamma. Este patrón permite añadir o eliminar funcionalidades a módulos de manera dinámica. En particular, lo que agregaremos será la verificación de cada argumento, manteniéndola separada del módulo que realiza la funcionalidad específica.

\declareCmod{Mecanismo}

Veamos un ejemplo en el cual se puede aplicar esta solución. Suponga que se tiene el módulo \Mecanismo cuya interfaz es la que se muestra en la Figura \ref{mecanismo}. Como se puede ver uno de los métodos es \verb|computar|, el cual debe verificar que el primer argumento sea siempre mayor a 0 y que el segundo sea par. En lugar de agregar el Código \ref{verificacion} al inicio de la implementación de \verb|computar|, proponemos usar dos módulos que actuen como decoradores.


\begin{figure}[H]
\caption{Interfaz del módulo Mecanismo.}
\label{mecanismo}
\begin{center}
\begin{tikzpicture}\sf

\umlclass[]{Mecanismo}
{}
{
...\\
computar(i: int, i: int)\\
...\\
}
\end{tikzpicture}
\end{center}
\end{figure}

\begin{lstlisting}[caption=Verificación de precondiciones en método Computar.,label=verificacion]
computar(int primer, int segundo){
	if (primer <= 0)
		return -1
	if (segundo % 2 != 0)
		return -1
	.
	.
	.
\end{lstlisting}

En la Figura \ref{estructuraDeco} se presenta la estructura de módulos conseguida aplicando el patrón.

\begin{figure}[h]
\caption{Ejemplo de aplicación del patrón \textit{Decorator} para garantizar el cumplimiento de precondiciones.}
\label{estructuraDeco}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{Mecanismo}{}
{
\umlvirt{...}\\
\umlvirt{computar(i: int, i: int)}\\
\umlvirt{...}
}

\umlclass[below left=2cm and -1cm of Mecanismo]{MecanismoConcreto}{}
{
...\\
computar(i: int, i: int)\\
...\\
}

\umlclass[below right=2cm and -1cm of Mecanismo,type=abstract]{Decorador}{}
{
\umlvirt{...}\\
\umlvirt{computar(i: int, i: int)}\\
\umlvirt{...}
}

\umlclass[below right=2cm and -1cm of Decorador]{PrimerArgPositivo}{}
{
...\\
computar(i: int, i: int)\\
...\\
}

\umlclass[below left=2cm and -1cm of Decorador]{SegundoArgPar}
{
}
{
...\\
computar(i: int, i: int)\\
...\\
}



\umlinherit[geometry=|-|]{MecanismoConcreto}{Mecanismo}
\umlinherit[geometry=|-|]{Decorador}{Mecanismo}
\umlinherit[geometry=|-|]{PrimerArgPositivo}{Decorador}
\umlinherit[geometry=|-|]{SegundoArgPar}{Decorador}
\umluniaggreg[geometry=-|-,arm1=2cm,anchor1=east,anchor2=east,arg1=mecanismo,
pos1=0.5]{Decorador}{Mecanismo}
\umlnote[left= 1cm of SegundoArgPar,width=7cm]{SegundoArgPar}{
computar(primero, segundo)\{ \\
if (segundo \% 2 != 0)\{\\
\ \ \ \	...manejar error...\\
\}else\{\\
\ \ \ \	return mecanismo.computar(primero, segundo)\\
\}\\
}


\end{tikzpicture}
\end{center}
\end{figure}






Siguiendo esos conceptos, las precondiciones necesarias por las funciones son garantizadas desde los módulos que almacenan los datos utilizados por estas últimas. De esa manera se estaría separando la responsabilidad de verificar precondiciones de las funciones y de los clientes. Para conseguirlo se puede utilizar el patrón \textit{Proxy} al rededor de un tipo básico (un \textit{array} de \textit{ints}, por ejemplo), y de esa manera proveer múltiples funciones que permitan verificar los rangos, consistencia y demás de \textit{features} de los datos. Y en caso de detectar un problema se llamará a un módulo que cumple el rol de \textit{handler} de errores, responsable de decidir como continuar. Este uso del patrón es mencionado por Gamma en el capitulo del mismo como una posible aplicación. Es decir, realizar operaciones extras cuando se accede a un objeto. Además, comenta que se pueden agregar más funcionalidades que las que menciona Douglass, como contar la cantidad de referencias a cierto objeto con el fin de liberar la memoria si nadie lo esta referenciando, verificar si un objeto está bloqueado por otro (mutex) o controlar el acceso a la información mediante permisos.

A continuación, se presenta un ejemplo en el que se dispone de un módulo denominado \textit{StockProducto}, encargado de almacenar información relacionada con el \textit{stock} de los productos. Dado que se trata de información relevante, es necesario incorporar validaciones tanto en el momento del almacenamiento como en la consulta de datos. Para el almacenamiento, se debe verificar que la cantidad ingresada no sea negativa, mientras que, al consultar, es fundamental asegurar que el usuario cuente con los permisos requeridos.

\begin{figure}[H]
\caption{Uso del patrón Proxy en el ejemplo del módulo stock y documentación del mismo.}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{StockAbstracto}
{
}
{
    \umlvirt{getStock(): int} \\
    \umlvirt{setStock(i: int)}
}

\umlclass[below left=2cm and -0.5cm of StockAbstracto]{StockProducto}
{
}
{
    getStock(): int \\
    setStock(i: int)
}

\umlclass[below right=2cm and -0.5cm of StockAbstracto]{StockProxy}
{
}
{
    getStock(): int \\
    setStock(i: int)
}


\umlclass[above right=1cm and 1.5cm of StockProxy]{ErrorHandler}
{
}
{
    manejarError(i: Error)
}


\umluniassoc{StockProxy}{StockProducto}
\umlinherit[geometry=|-|]{StockProxy}{StockAbstracto}
\umlinherit[geometry=|-|]{StockProducto}{StockAbstracto}
\umluniassoc[geometry=-|-]{StockProxy}{ErrorHandler}

\end{tikzpicture}
\end{center}

\begin{pattern}[]{Acceso seguro stock de productos}{Algorithm}{idFigAlg}
\based{Proxy (Apoderado)}
\why{\textbf{Cambios previstos}: Las diferentes precondiciones a cumplir pueden variar con el tiempo.

\textbf{Funcionalidad}: Controlar el acceso al stock, en particular con el fin de preservar la integridad.
}
\assigns
\is{StockAbstracto}{Sujeto}
\is{StockProducto}{SujetoReal}
\is{StockProxy}{Proxy}

\end{pattern}

\end{figure}
\textbf{ErrorHandler} decide como manejar el error, esto puede ser desde loggearlo, terminar la ejecución del sistema, ignorarlo, etc. Dos tipos de estrategias comunes al tratar con errores son:
\begin{itemize}
    \item Reset de componentes: reiniciar o restablecer componentes defectuosos ayuda a borrar errores y restaurarlos a un estado funcional.
    \item Degradación elegante \cite{glass2009graceful} permite que el sistema siga funcionando a una capacidad reducida en lugar de fallar por completo. Esto implica deshabilitar las funciones que funcionan mal o cambiar a copias de seguridad, por lo que el sistema continúa funcionando con una funcionalidad limitada en lugar de apagarse por completo.
\end{itemize}


Con este diseño añadimos una capa de verificación sin modificar el módulo original, ya que \verb|getStock| y \verb|setStock| de \textit{StockProxy} van a realizar la verificación indicada y luego si todo es correcto invocarán los métodos de \textit{StockProducto}. Con esto conseguimos las siguientes ventajas:

\begin{itemize}
    \item Encapsular la lógica de validación y control de acceso en un solo lugar, sin necesidad de modificar el módulo original que gestiona los datos. Facilitando la reutilización y la separación de responsabilidades.

    \item Centraliza el control sobre cómo y cuándo se accede o modifica el dato sensible. Esto facilita la implementación de reglas de negocio más complejas, como la validación de entradas, sin tener que modificar cada parte del código que interactúa con \textbf{StockProducto}.

    \item Extender funcionalidades, el proxy puede evolucionar independientemente del modulo SujetoReal (ver \ref{patronProxy}), añadiendo nuevas funciones o cambiando las reglas de validación sin afectar la implementación original del módulo que contiene los datos. Por ejemplo, se pueden implementar restricciones de acceso, límites en las operaciones permitidas o incluso operaciones en diferido, sin necesidad de modificar el objeto real.
\end{itemize}

\section{Control en conjunto de dispositivos}
Muchas aplicaciones embebidas robóticas controlan \gls{actuadores} que deben trabajar en conjunto para lograr el efecto deseado. Por ejemplo, para conseguir mover de manera coordinada un brazo robótico con múltiples articulaciones, todos los motores deben trabajar a la par. De manera similar, el uso de propulsores en una nave espacial en tres dimensiones requiere que muchos de estos dispositivos actúen en el momento preciso y con la cantidad correcta de fuerza para lograr la estabilidad necesaria. En ambos casos existe comunicación entre todos los componentes, ya sea para encadenar la ejecución de ciertos movimientos o para avisar de restricciones. Esto no es tarea simple y requiere de muchas lineas de código, por lo que un diseño orientado al cambio resulta clave.

\subsection*{Solución tradicional}

Antes de pasar a explicar la solución propuesta y analizar cómo aplicarla al ejemplo presentado por Douglass en su libro \cite{douglass}, se describirá cómo se aborda tradicionalmente esta problemática. Para ello, se tomará como ejemplo el software desarrollado para el robot desmalezador antes de la propuesta del nuevo diseño \cite{paperPomponio}. En particular, existieron dos desarrollos creados en conjunto por ingenieros electrónicos como parte del trabajo final de carrera \cite{disenioViejo1, disenioViejo2}. Los requerimientos son similares a los que se consideraron para el desarrollo del nuevo diseño.

\subsubsection*{Estructura y funcionamiento general}

El sistema desarrollado controla el siguiente hardware:

El robot cuenta con cuatro ruedas y un dispositivo de dirección que les permite girar. Cada rueda tiene sensores \gls{hall}¸, que permiten medir su posición y velocidad, y un sistema asociado de medición de corriente. El dispositivo de dirección permite determinar su posición angular en cada momento. Tanto las ruedas como el dispositivo de dirección pueden ser operados de forma remota mediante un control remoto (RC), capaz de enviar señales de dirección y velocidad a un módulo receptor de radiofrecuencia (RF) situado en el robot. Además, una computadora (PC) situada en el robot envía órdenes al dispositivo de dirección y a las ruedas para la navegación autónoma del robot. Las órdenes provenientes tanto del RC como de la PC son procesadas por un microcontrolador ubicado en el robot.

El código que conforma el sistema de control se encuentra dividido en unos pocos archivos, concentrando todo el flujo de control en \verb|main.c|, el resto contienen métodos que son invocados desde este último y proveen utilidades. No se utiliza programación orientada a objetos, en cambio, como estructura de organización del código se utilizan las funciones clásicas de C. Estas parece que encapsulan operaciones específicas como:
\begin{itemize}
\item Configuración de hardware.
\item Lectura de entradas (sensores, botones, etc.).
\item Control de salidas (motores, luces, etc.).
\end{itemize}

La información común entre muchas funciones se almacena en variables globales definidas en el mismo archivo. Entre las variables, encontramos algunas que se encargan de almacenar información referida al estado de operacion del sistema. Es decir, que los estados se manejan con sentencias \verb|if| o \verb|switch case| (se comenta sobre esta solución en la sección \nameref{cap:state}).

La función principal del sistema es \verb|main|, la misma se encarga de inicializar y calibrar los sensores y actuadores, de realizar el ciclo de control y terminar la ejecución. Para las primeras dos tareas llama a dos funciones que realizan el trabajo. El ciclo dSolución orientada al cambio}e control se ve representado por un bucle infinito en el cual se realizan las siguientes tareas principales:
\begin{itemize}
\item Lectura de información de los sensores, dirección, velocidad y corriente.
\item En base al estado de ejecución actual, se realizan ciertas tareas.
\item Se aplican cambios a los actuadores, el ciclo de trabajo (\gls{PWM}) de los motores y la dirección.
\end{itemize}

\subsubsection*{Observaciones}
El criterio de división del código parece ser funcional, tanto por el aspecto del código, como por la documentación adjunta en los informes \cite[pág. 78-85]{disenioViejo1}, \cite[pág. 110-149]{disenioViejo2}. Esta última, se centra es describir la funcionalidad de cada método y para hacerlo se muestra su comportamiento utilizando diagramas de flujo como el de la figura \ref{diagra}. 

\begin{figure}[h]
\caption{Diagrama de flujo que explica el comportamiento de la función emergency \cite[pág. 82]{disenioViejo1}.}
\label{diagra}
\begin{centering}
{\includegraphics[width=0.8\textwidth]{diagramaFlujo.png}\par}
\end{centering}
\end{figure}


Por otro lado, a lo largo del código se utilizan estructuras condicionales (if, switch, etc.) para determinar el flujo de ejecución. A su vez, las funciones que acceden directamente al hardware están directamente integradas en la lógica del control, lo que indica una baja separación entre la capa de abstracción del hardware y la lógica de ``alto'' nivel. Esto es acompañado con un diseño procedimental, con una serie de pasos secuenciales y un control centralizado en el flujo principal. Ademas, el hardware se encuentra integrado a la lógica, se aplican estructuras condicionales directamente a este.

Otros inconvenientes referidos al cambio que están presentes en el código:
\begin{itemize}
\item El código parece estar compuesto por funciones largas y bloques monolíticos sin modularidad clara. Esto dificulta la localización y modificación de funcionalidades específicas, ya que los cambios pueden propagarse a otras partes del sistema.
\item Hay valores ``hardcodeados'' (constantes definidas fijas en el código). Si estos valores cambian, es necesario modificar el código fuente, aumentando el riesgo de introducir errores.
\item Las dependencias entre funciones están estrechamente acopladas. Lo que provoca que los cambios puedan requerir modificaciones significativas en diferentes secciones de código.
\item El manejo de errores parece ser inconsistente o inexistente en varias secciones. Esto puede llevar a comportamientos impredecibles y dificultar el diagnóstico de problemas.
\end{itemize}

\subsubsection*{Conclusión}

El diseño del código parece estar orientado a cumplir con un objetivo específico mediante un flujo procedimental y un control directo de los periféricos del hardware. Este enfoque es funcional, pero carece de modularidad y abstracción, lo que lo hace menos flexible y más difícil de mantener. La estructura actual no parece diseñada para escalar con nuevas funcionalidades. Lo que tiene sentido, si se tiene en cuenta el contexto del desarrollo.


\subsection{Subsistemas de control}

Para dar la solucion orientada al cambio, primero se introducirá el concepto de \textbf{Subsistema de control}. Un subsistema de control es una estructura de módulos relacionados mediante herencia, composición o invocación, que responde al control de una propiedad física particular del sistema embebido de control en el que se va a aplicar. Para hacerlo lleva a cabo todas las tareas de la arquitectura de \nameref{arqControlProc} en el nivel conceptual de módulos. 

A fin de aplicar la arquitectura de software de control de procesos, se propone la creación de un \textit{subsistema de control} por cada variable a manipular\footnote{Ver tabla conceptos arquitectura Control de Procesos \ref{tab:conceptosArq}} que sea necesaria controlar por el sistema. Para permitir la interacción con un cliente externo debe proveer una interfaz que permita setear un valor al que se quiera llevar la propiedad (\textit{setPoint} (ver tabla \ref{tab:conceptosArq})) y que indique el comienzo de la tarea de control. Un subsistema tiene una estructura similar a la de la arquitectura \ref{fig:arqCtrlRobot}, pero su alcance estará restringido a la variable a manipular y las variables medidas relacionadas. En la figura \ref{modulosSub} se puede observar de manera concreta los módulos que forman parte de cada componente de un subsistema.


\begin{figure}[H]
\caption{Módulos de un subsistema de control.}
\label{modulosSub}
\begin{center}
\begin{tikzpicture}\sf

\umlclass[]{Control}
{}
{setPoint(i: Measure)\\
control() \\
connectionRead() \\
setAlgoritmo(i: Algoritmo) \\
setConnection(i: Pipe)
}

\umlclass[below=6cm of Control]{Sensor}
{}
{setConnection(i: Pipe) \\
signal()
}
\umlnote[below left=-1cm and 1cm of Sensor,width=4cm]{Sensor}{
signal()\{ \\
\ \ \ \ value = getValue()\\
\ \ \ \ pipe.write(value)\\
\}
}

\umlclass[below=3cm of Control]{Actuador}
{}
{actuar()
}
\umlclass[left=2cm of Actuador]{Pipe}
{}
{read(): Measure \\
write(i: Measure)
}


\umlnote[below right=0.5cm and 2cm of Actuador, width=5cm]{Actuador}{
Por lo general se desacopla usando el patrón \textit{command} y su uso puede ser más complejo que solo ejecutar una función.
}



\umlclass[above right=-1cm and 2cm of Control]{Algoritmo}
{}
{calcular(): Measure
}
\umlclass[below right=-1.5cm and 2cm of Control]{Data}
{}
{setSetPoint(i: Measure) \\
getSetPoint(): Measure \\
setCurrent(i: Measure) \\
getCurrent(): Measure
}

\umluniaggreg[anchor1=10,anchor2=west]{Control}{Algoritmo}
\umluniaggreg[anchor1=-10,anchor2=west]{Control}{Data}

\end{tikzpicture}
\end{center}
\end{figure}

Los módulos principales son los siguientes:

\begin{itemize}
\item \textbf{Control}: encargado de proveer una interfaz a clientes desde la cual se realizan todas las tareas referidas al control.
\item \textbf{Actuador}: encapsula el dispositivo de hardware que manipula la variable física.
\item \textbf{Sensor}: encapsula el dispositivo de hardware utilizado para recibir información del mundo físico, pueden existir múltiples sensores.
\item \textbf{Pipe}: módulo utilizado para desacoplar la comunicación entre \textbf{Control} y los sensores.
\end{itemize}


La manera en la que un \textit{cliente} utiliza el subsistema para lograr que la propiedad que controla se ubique en el valor que se desea es de la indicada en el código \ref{usoSubsistema}. Primero se configura el \textit{set-point} deseado, luego se  una señal a los sensores para que escriban en el pipe los valores leídos, luego se lee la información y se indica el ciclo de control invocando \verb|control|.

\begin{lstlisting}[caption=Ejemplo de uso del subsistema.,label={usoSubsistema},style=seudocode]
control.setPoint(valorDeseado)
sensor.signal()
control.connectionRead()
control.control()
\end{lstlisting}

Notar que en \ref{modulosSub} aparecen algunos módulos que no fueron mencionados anteriormente, por un lado \textbf{Algoritmo} el cual se encarga de los cálculos necesario para determinar de que manera aplicar un cambio con el/los actuadores. Determina si se llego o no al \textit{set-point} y a su vez define qué cambio es necesario aplicar para llegar al mismo. En el ámbito de la robótica se aplican diferentes técnicas de estabilización\footnote{La estabilización es crucial para evitar oscilaciones, reducir el tiempo de respuesta y minimizar sobrepasos, garantizando un control preciso y eficiente. Un sistema bien ajustado responde de manera estable ante perturbaciones externas y optimiza el consumo energético, mejorando la fiabilidad y el desempeño en aplicaciones como robótica y automatización.} de variables físicas, las cuales permiten alcanzar un cierto \textit{set-point} y mantenerse en el, por ejemplo, los controladores \gls{PID}\cite{pidlibro} (controlador proporcional, integral y derivativo). Los cuales representan un mecanismo de control que, a través de un lazo de retroalimentación, permiten manejar una variable física. Este tipo de técnicas puede ser usada siguiendo la arquitectura propuesta y, en particular, los cálculos asociados se definirían en este módulo \textbf{Algoritmo}.

Por otro lado, \textbf{Data} desacopla el almacenamiento de información relacionada al subsistema. En el caso más básico solo se almacena el \textit{set-point}, pero puede agregarse todo lo necesario, incluso llevar registro de los valores actuales y pasados de cada variable de interés.

Ahora, para brindar un comportamiento más complejo, es posible que el control necesite realizar múltiples ciclos para ajustar la variable al valor deseador, como pasa cuando se manejan motores paso a paso (luego se expandirá esto en un ejemplo). ¿Cómo se puede adaptar la estructura propuesta para dar soporte a esta característica? Se necesitan dos modificaciones/adiciones, por un lado, una interrupción de control que llame a cierto método del módulo \textbf{Control} cada determinado tiempo (tiempo del ciclo), generalmente resuelto con una interrupción \textit{temporizada} y por el otro, se debe añadir la noción de estado al módulo de control. De modo que existan dos estados básico, en espera, cuando no se esta realizando un ciclo de control y trabajando, cuando se haya establecido un \textit{set-point} y se este activamente trabajando para llegar a él. Para hacerlo se hace uso de un nuevo método y el patrón \textit{state}\footnote{El uso de este patrón está explicada en la sección \nameref{cap:state}.} y se obtiene el esquema \ref{controlState} (en \ref{docStateControl} se encuentra la documentación de la aplicación del patrón).

\begin{figure}[H]
\caption{Estructura módulo \textbf{Control} extendida con estado.}
\label{controlState}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=-4]{Control}
{}
{setPoint()\\
control() \\
cicle() \\
leer() \\
setAlgoritmo(i: Algoritmo) \\
changeState(i: State)
}
\umlnote[x=-5, y=5, width=4cm]{Control}{
Delega al estado interno tanto control() como cicle()
}

\umlclass[x=4, y=3,type=abstract]{State}
{}
{
\umlvirt{control()} \\
\umlvirt{cicle()} \\
}

\umlclass[x=2,y=-2]{Waiting}
{}
{
control() \\
cicle() \\
}


\umlclass[x=6,y=-2]{Working}
{}
{
control() \\
cicle() \\
}

\umlinherit[geometry=|-|]{Waiting}{State}
\umlinherit[geometry=|-|]{Working}{State}
\umluniaggreg[geometry=-|-]{Control}{State}

\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}
\caption{Documentacion de la aplicación del patrón State en el módulo Control.}
\label{docStateControl}
\begin{pattern}[]{Estados de operación del controlador}{Algorithm}{idFigAlg}
\based{Estado (State)}
\why{\textbf{Cambios previstos}: El controlador lleva a cabo el control dependiendo del estado en el que se encuentre. Podrían cambiar el comportamiento requerido de algunos de los estados definidos o bien podría ser necesario agregar nuevos estados con sus correspondientes comportamientos.

\textbf{Funcionalidad}: Dependiendo del estado, los métodos control y cicle deben comportarse de manera diferente. A su vez, pueden cambiar de manera dinámica. En caso de que no se esté realizando una acción sobre alguno de los actuadores que 
}
\assigns
\is{Control}{Contexto}
\is{State}{Estado}
\is{Waiting}{EstadoConcreto}
\is{Working}{EstadoConcreto}
\end{pattern}
\end{figure}


El cliente ejecuta \verb|control()| y la interrupción que marca el ciclo de trabajo ejecuta \verb|cicle()|. De esta manera, cuando el estado es \textit{waiting}, \verb|cicle()| no hace nada y cuando está en \textit{working} \verb|control()| no hace nada y la otra función se encarga de realizar el ciclo de control.
Por supuesto, estas dos funciones son las encargadas de llamar a \verb|changeState()| cuando sea necesario. \verb|control()| cambia a \textit{working} y cuando se alcanza el \textit{set-point}, \verb|cicle()| cambia el estado a \textit{waiting}.

En el diseño del robot desmalezador \cite{paperPomponio} existe un \textit{timer} que desencadena una interrupción cada 1.5\textit{ms} la cual ejecuta el ciclo de control del subsistema de dirección del robot. Este consta de un motor paso a paso, por lo que cada ciclo verifica la diferencia de posición actual con la deseada y si no se llego al mínimo de diferencia deseado se envía un pulso al motor para que avance.

Antes de ver un ejemplo repasemos que conseguimos al usar los subsistemas de control. Principalmente encapsulamos el control de cada propiedad de manera independiente, permitiendo que cada una pueda modificarse de manera aislada. Además, se logra que agregar nuevas propiedades con su conjunto de actuadores y sensores conste únicamente en crear nuevos módulos. Se provee una capa de abstracción para construir sobre los sistemas un controlado general que involucre múltiples subsistemas. Este controlador general organizará los esfuerzos de cada uno con el fin de llevar a cabo comportamientos más complejos.

\subsection{Ejemplo}

Se utilizará como ejemplo el propuesto en el libro \cite{douglass} en la sección de 3.4 \textit{Mediator Pattern}.

\subsubsection*{Requisitos}

Se necesita desarrollar el software de control de un brazo robótico que consta de tres actuadores, dos servomotores (uno para rotar y otro para extender o retraer el brazo) y una pinza que se puede cerrar o abrir. Para ello, se provee una función compleja la cual toma coordenadas en el espacio y genera una secuencia de ordenes para que el brazo tome un objeto en la posición determinada por las coordenadas. La secuencia es una serie de pasos, y cada uno consta de una orden para cada actuador del brazo robótico. Estos se deben ejecutar de manera secuencial, es decir que el paso número 2 empezará su ejecución solo si el primero culmino completamente y con éxito. En caso de que las coordenadas sean inalcanzables devuelve 0 pasos. A su vez cada actuador puede informar un error al intentar ejecutar cada movimiento, y si esto pasa se requiere frenar la ejecución total del sistema.

\begin{figure}[h]
\caption{Esquema del brazo robótico.}
\begin{centering}
{\includegraphics[width=0.5\textwidth]{brazo3.png}\par}
\end{centering}
\end{figure}

\subsubsection*{Solución propuesta en el libro de Douglass}

El ejemplo que plantea el libro es similar al descrito, pero el brazo robótico tiene más articulaciones y actuadores. Como solución, se propone la creación de un módulo llamado \textbf{RobotArmManager}, cuya función es gestionar los actuadores y coordinar su comportamiento. Además, para cada tipo de articulación o actuador, se crea un módulo específico encargado de su control. Este módulo proporciona métodos para consultar el estado actual (posición, longitud, etc.) y otros para configurar un valor similar a un \textit{set-point}. Dichos métodos desempeñan el rol de ejecutores de la acción, es decir, toman un valor \textit{set-point}, ejecutan la acción y retornan \verb|True| si fue satisfactoria, o \verb|False| en caso contrario.

El comportamiento del sistema comienza con la generación de una lista de pasos a realizar. Luego, se itera sobre esta lista ejecutando las acciones definidas en cada paso. Como el sistema debe interrumpir la ejecución si encuentra un error, el \textbf{RobotArmManager} verifica el valor de retorno tras cada acción. La ejecución de un movimiento completo finaliza cuando se completan todos los pasos generados previamente por el método \verb|graspAt(i: Coordenadas)|.

La solución propuesta parece estar un nivel por encima de lo que se esperaría para este caso. Aunque no hay suficiente información sobre el hardware del brazo robótico, generalmente mover una articulación no es tan simple como invocar un método. Este proceso suele requerir el control continuo de un motor paso a paso, que opera mediante pulsos que avanzan un paso. Por lo tanto, los módulos encargados de los movimientos probablemente tengan más responsabilidades de las que se plantean en el libro. Además, sería necesario implementar un sistema de control más complejo, utilizando algún tipo de \textit{timer} o espera, para garantizar que el motor paso a paso tenga el tiempo necesario para actuar.

De todas formas, suponiendo que los módulos mencionados se adaptan al hardware subyacente, la manera en la que el \textbf{RobotArmManager} interactúa con ellos resulta rígida, tanto por la invocación directa como por la dependencia del valor de retorno. Esto se evidencia en el código resultante, que incluye múltiples sentencias \textit{if} consecutivas.

Por otro lado, un ítem de cambio común son las estructuras de datos, como se mencionó en \ref{listaItems}. Por ello, establecer el uso de una lista directamente en el diseño no responde a una buena práctica.

Es posible que el problema haya sido simplificado con fines didácticos. Sin embargo, la forma planteada parece alejarse de una implementación realista, dejando requisitos menos específicos que podrían dar lugar a diferentes interpretaciones.

Por le lado de la aplicación del patrón \textit{Mediator}, los autores en \cite{Gamma:1995:DPE:186897} establecen que es aplicable en los siguientes casos:
\begin{itemize}
\item Un conjunto de módulos se comunica de maneras bien definidas pero complejas. Las interdependencias resultantes son desestructuradas y difíciles de comprender.

\item Reutilizar un módulo resulta complicado porque este se refiere y se comunica con muchos otros módulos.

\item Un comportamiento distribuido entre varios módulos debería ser personalizable sin requerir una gran cantidad de submódulos.
\end{itemize}

La estructura lograda es similar al patrón, pero originalmente los módulos encargados de ejecutar tareas relacionadas con un actuador específico no necesitaban comunicarse entre sí. Según el propósito del patrón, el objetivo principal es reducir el acoplamiento, evitando que los módulos se refieran directamente entre ellos. Y este objetivo parece estar logrado en el diseño propuesto.

\subsubsection*{Solución orientada al cambio}

Se aplica el concepto de subsistemas que se introdujo previamente, para ello primero se debe identificar las propiedades del mundo físico a controlar. Claramente, lo que se requiere es modificar la posición y el estado de la pinza del brazo, para hacerlo se cuenta con distintos actuadores que intervienen diferentes propiedades físicas. Además, en los requisitos se especifica que se cuenta con una función que genera una orden para cada actuador. De esta manera se define un subsistema de control por cada actuador que serán los encargados de llevar a cabo las ordenes generadas. Un ejemplo de orden es rotar 30\textdegree, es claro el \textit{set-point} que se está indicando. Para coordinar los subsistemas se propone un controlador principal llamado \textbf{MainController}, el cual provee el método \verb|graspAt(i: Coordenadas)| al cliente, realiza la generación de los pasos y controla su ejecución. La estructura es como la que se describe en la figura \ref{diagramaRobotico}.


\begin{figure}[h]
\caption{Diagrama de los componentes del sistema brazo robótico.}
\label{diagramaRobotico}
\begin{center}
\includegraphics[scale=0.6]{componentes.png}
\end{center}
\end{figure}



Se puede pensar que el gráfico tiene cierta similaridad conceptual con el patrón \textit{mediator}, donde un módulo \textbf{Mediator} coordina el trabajo de los \textbf{College} en este caso los subsistemas. Gamma en \cite{Gamma:1995:DPE:186897} indica que el patrón suele ser apropiado para casos en lo que se tiene un conjunto de objetos que se comunican de manera compleja pero fija. En este caso la comunicación no es tan compleja, pero puede considerarse lo suficiente como para implementar el patrón. En particular, el \textbf{MainController} indica los \textit{set-point} de cada subsistema y desencadena el proceso de control en cada uno. Y viceversa, los subsistemas indican cuando llegan al \textit{set-point} o cuando se encuentran un error. A su vez, los subsistemas no se comunican de manera directa entre si, todo pasa por el \textbf{MainController}.

\begin{figure}[h]
\caption{Actuadores paso a paso.}
\label{estructuraActuadores}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{StepDevice}
{}
{
\umlvirt{right()} \\
\umlvirt{left()} \\
\umlvirt{disable()}\\
\umlvirt{enable()} \\
\umlvirt{pulse()}
}

\umlclass[below left=1cm and -0.3cm of StepDevice]{Rotor}
{}
{
right() \\
left() \\
disable() \\
enable() \\
pulse()
}

\umlclass[below right=1cm and -0.3cm of StepDevice]{Extensor}
{}
{
right() \\
left() \\
disable()\\
enable() \\
pulse()
}

\umlinherit[geometry=|-|]{Rotor}{StepDevice}
\umlinherit[geometry=|-|]{Extensor}{StepDevice}

\end{tikzpicture}
\end{center}
\end{figure}
Ahora, se detallarán los módulos que conforman cada componente comenzando por los módulos básicos que debemos crear para representar el hardware dado. Los módulos del gráfico \ref{estructuraActuadores} representan motores paso a paso\footnote{Se utiliza el mismo diseño propuesto para el robot desmalezador\cite{paperPomponio}.}, los cuales para ser controlados se deben primero configurar su dirección invocando a los métodos \verb|right| o \verb|left| para luego avanzar un paso llamando al método \verb|pulse|. Claramente para que lleguen a la posición deseada puede ser necesario invocar reiteradas veces al método \verb|pulse|. Esto será importante a la hora de diseñar el subsistema que controlará cada dispositivo.

En cambio, en el caso de la pinza (ver \ref{moduloPinza}) se utiliza un dispositivo que tiene dos estados, abierto o cerrado, por lo que solo se tienen dos métodos para cambiar entre estados.

\begin{figure}[h!]
\caption{Interfaz módulo Pinza.}
\label{moduloPinza}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Pinza}
{}
{
abrir() \\
cerrar()
}

\end{tikzpicture}
\end{center}
\end{figure}

En \ref{sensores} se encuentran definidos los sensores asociados a cada actuador, estos heredan del módulo sensor pasivo el cual provee dos funciones, \verb|setConnection(i: Pipe)| la cual configura el \textbf{Pipe} por el cual se enviará la información obtenida del sensor cuando la otra funciones, \verb|signal()| sea invocada.

\begin{figure}[h]
\caption{Sensores del brazo robótico.}
\label{sensores}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{PasiveSensor}
{}
{
\umlvirt{setConnection(i: Pipe)} \\
\umlvirt{signal()} \\
}

\umlclass[x=-5,y=-4]{SensorEstadoPinza}
{}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlclass[x=0,y=-4]{SensorPosRotor}
{}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlclass[x=5,y=-4]{SensorPosExtensor}
{}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlinherit[geometry=|-|]{SensorEstadoPinza}{PasiveSensor}
\umlinherit[geometry=--]{SensorPosRotor}{PasiveSensor}
\umlinherit[geometry=|-|]{SensorPosExtensor}{PasiveSensor}


\end{tikzpicture}
\end{center}
\end{figure}

Para completar los módulos que conforman a un subsistema de control falta mostrar como se define el \textbf{Controller}. Se diferencian dos tipos de \textbf{Controllers}, uno para los actuadores que requieren un control durante un determinado lapso de tiempo para poder llegar a su \textit{set-point} y los que no. En este ejemplo, tenemos dos motores paso a paso que representan el primer tipo y la pinza que corresponde al segundo. Vemos primero el caso más ``complejo'', como el proceso de control se extiende en el tiempo necesitamos añadir al sistema un mecanismo por el cual cada cierto intervalo ejecute un ciclo de control, es decir, lea la posición actual, decida y actúe. Para eso, en el diseño del robot desmalezador \cite{paperPomponio} se propuso la creación de una interrupción temporizada, la cual se ejecuta cada 1.5\textit{ms} y desencadena el control de los subestimas necesarios. El módulo encargado de esta tarea es \textbf{Timer} y su interfaz se puede ver en la figura \ref{moduloTimer}.


\begin{figure}[h!]
\caption{Módulo Timer}
\label{moduloTimer}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Timer}
{}
{
setPeriod(i: Real) \\
start() \\
stop() \\
tickHandler()
}

\umlnote[above right=-2cm and 1cm of Timer,width=7cm]{Timer}{
tickHandler() \{ \\
subsistemControlTimeout.execute() \\
\}
}

\umlsimpleclass[below right=0cm and 2cm of Timer]{Command}
\umluniassoc[geometry=|-]{Timer}{Command}
\end{tikzpicture}
\end{center}
\end{figure}

El método \verb|tickHandler()| ejecutará comandos siguiendo patrón \textit{Command} por cada subsistema que lo necesite, por lo tanto se iniciará en cada uno el ciclo de control. En particular, la orden es utilizada para desacoplar como es invocado el inicio del \textbf{Timer}. En la figura \ref{docCommandTimer} se puede observar la documentación de la aplicación del patrón \textit{Command} para este caso.

\begin{figure}
\caption{Documentacion de la aplicación del patrón Command para el desacople de ejecuciones que invoca el Timer.}
\label{docCommandTimer}
\begin{pattern}[]{Comando para manejar interrupciones generadas por el Timer.
Sustitución de callback}{Algorithm}{idFigAlg}
\based{Orden (Command)}
\why{\textbf{Cambios previstos}: Las acciones a llevar a cabo ante una interrupcion provocada por el Timer podrían cambiar; o incluso podría cambiar el receptor de dichas acciones, que actualmente es Controller.

\textbf{Funcionalidad}: Se mantienen los niveles de abstracción. El módulo Timer, desconoce la existencia de módulos de niveles superiores como el Controller.
}
\assigns
\is{Command}{OrdenConcreta}
\is{Timer}{Invocador}
\is{Controller}{Receptor}
\end{pattern}
\end{figure}


Una vez solucionada la invocación, se debe introducir un nuevo módulo que será usado en el \textbf{Controller}. Ahora, se tienen dos modos de operación en este último, cuando se está trabajando, es decir, se tiene configurado un \textit{set-point} y aun no se alcanzó, y cuando no. Dependiendo de cual de los dos esté activo el comportamiento será diferente, por ejemplo, como no se apaga el \textbf{Timer} cuando no se está haciendo un movimiento, es necesario ignorar las llamadas de control. Para esto se hace uso del patrón \textit{State} de Gamma\cite{Gamma:1995:DPE:186897}, el cual está explicado en la sección \ref{cap:state}. Esta aplicacion del patron \textit{State} al caso de manejo de una interrupcion está explicado en la sección \nameref{orgEjecucion}. En particular, el \textbf{Controller} delegará dos métodos de su interfaz al módulo del patron \textit{state}, \verb|control()| y \verb|move()| (luego lo se verá en detalle). La estructura de módulos resultante es la presente en \ref{operationState}.

\begin{figure}[h]
\caption{Módulos que forman parte del patrón State que son necesarios para complementar al módulo Controller}
\label{operationState}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{OperationState}
{}
{
\umlvirt{control(i: Controller)} \\
\umlvirt{move(i: Controller)} \\
}

\umlclass[x=-3,y=-4]{Moving}
{}
{
control(i: Controller) \\
move(i: Controller) \\
}

\umlclass[x=3,y=-4]{Waiting}
{}
{
control(i: Controller) \\
move(i: Controller) \\
}

\umlinherit[geometry=|-|]{Moving}{OperationState}
\umlinherit[geometry=|-|]{Waiting}{OperationState}

\end{tikzpicture}
\end{center}
\end{figure}

Siguiendo con la guía de creación de subsistemas, también se debe definir el módulo \textbf{Data} que almacena la información utilizada por el mismo y el módulo \textbf{Algoritmo} que encapsula los cálculos necesarios para determinar que cambio aplicar. Se pueden observar en la figura \ref{complementariosController}.

\begin{figure}[h]
\caption{Módulos complementarios a Controller.}
\label{complementariosController}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=-3]{Data}
{}
{
setSetPoint(i: Measure) \\
getSetPoint(): Measure \\
setCurrent(i: Measure) \\
getCurrent(): Measure
}

\umlclass[x=3]{Algoritmo}
{}
{
compute(i: Data): Measure
}

\end{tikzpicture}
\end{center}
\end{figure}

Con todos los módulos necesario ya definidos, la estructura del \textbf{Controller} se puede ver en la figura \ref{estructuraController}.

\begin{figure}[H]
\caption{Estructura módulo Controller}
\label{estructuraController}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Controller}
{}
{
setConnection(i: Pipe) \\
readConnection() \\
setSetPoint(i: Measure) \\
getData(): Data \\
getAlgoritmo(): Algoritmo \\
changeOperationState(i: OperationState) \\
move() \\
control()
}

\umlsimpleclass[above right=-1.5cm and 1cm of Controller]{Data}
\umlsimpleclass[above right=-2.5cm and 1cm of Controller]{Algoritmo}
\umlsimpleclass[above right=-3.5cm and 1cm of Controller]{OperationState}
\umlsimpleclass[above right=-4.5cm and 1cm of Controller]{Pipe}

\umluniaggreg[anchor1=22,anchor2=west]{Controller}{Data}
\umluniaggreg[anchor1=7,anchor2=west]{Controller}{Algoritmo}
\umluniaggreg[anchor1=-7,anchor2=west]{Controller}{OperationState}
\umluniaggreg[anchor1=-22,anchor2=west]{Controller}{Pipe}

\end{tikzpicture}
\end{center}
\end{figure}

La funcionalidad de cada método que provee la interfaz de \textbf{Controller}:
\begin{itemize}
    \item \verb|setConnection|: configura el tubo por el cual llegará la información proveniente de el/los sensores.
    \item \verb|readConnection|: lee del pipe y almacenar la información en el módulo data.
    \item \verb|setSetPoint|: se utiliza antes de comenzar el control para configurar el valor al que se quiere llegar.
    \item \verb|getData|: devuelve el objeto Data asociado al \textbf{Controller}.
    \item \verb|getAlgoritmo|: lo mismo que con Data.
    \item \verb|changeOperationState|: cambia el estado del modo de operación, en la configuración básica las transiciones posibles son de \textit{Waiting} a \textit{Moving} y viceversa.
    \item \verb|move|: es el método ejecutado en cada timeout del \textbf{Timer} de control, realiza un paso del ciclo de control si el estado es \textit{Moving}.
    \item \verb|control|: se utiliza para comenzar el ciclo de control, es el puntapié inicial que desencadena el comportamiento de todo el subsistema.
\end{itemize}

Suponga que un cliente quiere utilizar el subsistema, ¿qué métodos tiene que ejecutar si ya está inicializado? Primero debe indicarle a los sensores que escriban el valor de lectura en el pipe, para esto hay que ejecutar el método \verb|signal| en cada uno. Luego el \textbf{Controller} debe leer esta información del pipe y almacenarla, para esto ejecutamos \verb|readConnection|. Ahora, seteamos el setPoint deseado y por ultimo ejecutamos \verb|control|, la cual tomará los valores actuales, el \textit{set-point} y decidirá utilizando el módulo \textbf{Algoritmo} que cambio realizar en los actuadores. En el caso del \textbf{Rotor}, por ejemplo, podrá tanto cambiar la dirección de giro, como avanzar un paso ejecutando \verb|pulse()|. Un ejemplo del metodo \verb|control()| para el caso del subsistema del \textbf{Rotor} y estado de operación \textit{Waiting}, puede ser la del código \ref{impControl} (recordar que el \textit{set-point} del subsistema del rotor es una medida en grados).

\begin{lstlisting}[caption=Ejemplo de implementación del método control del módulo Controller.,label={impControl}]
    void control(Controller controller) {
        setPoint = data.getSetPoint();
        current = data.getCurrent();
        dif = controller.algoritmo.calculate()
        if abs(dif) > LIMIT_ACCEPT && dif > 0 {
            rotor.left();
            rotor.pulse;
            controller.changeOperationState(moving);
            return;
        }
        if abs(dif) > LIMIT_ACCEPT && dif < 0 {
            rotor.right();
            rotor.pulse;
            controller.changeOperationState(moving);
            return;
        }
    }
\end{lstlisting}

El método \verb|move| tendrá un comportamiento similar pero en el aso de cambiar de estado lo hará a \textit{Waiting}. Para el caso de la \textbf{Pinza}, el \textbf{Controller} es más simple ya que no necesitamos los estados, pero el uso y comportamiento es similar. Por lo que para este ejemplo, vamos a necesitar crear dos subsistemas con estados y uno sin.

Ya se definieron los subsistemas, por lo que siguiendo con el diagrama \ref{diagramaRobotico}, falta entonces abarcar el \textbf{MainController}. Este último se encarga de brindar una interfaz al cliente y a su vez coordinar cada subsistema. Recordando los requerimientos, sabemos que tenemos una función que generar una secuencia de pasos donde cada uno implica una acción sobre los tres actuadores. ¿Cómo se puede diseñar este comportamiento? Una opción es usar un \textit{iterator} para recorrer los pasos y aplicar el patrón \textit{command} para cada uno. En particular, se aplica una de las modificaciones del patrón mencionada por Gamma\cite{Gamma:1995:DPE:186897}, en donde una orden al ser ejecutada desencadena la ejecución del resto de las ordenes. Esto se puede ver en los gráficos \ref{iterator}, \ref{orden} y \ref{docCommandSteps}. A su vez en \ref{ejemploOrdenRotor} se encuentra un ejemplo de una posible implementación del módulo OrdenRotor.

\begin{figure}[h]
\caption{Interfaz módulo Steps y documentación de aplicación del patrón Iterator.}
\label{iterator}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Steps}
{}
{
primero() \\
siguiente()\\
elementoActual(): Orden\\
haTerminado(): Bool\\
}


\end{tikzpicture}
\end{center}
\begin{pattern}[]{Ordenes a ejecutar para realizar el movimiento requerido.}{Algorithm}{idFigAlg}
\based{Iterador (Iterator)}
\why{\textbf{Cambios previstos}: Se pueden agregar, quitar o modificar ordenes pero siempre con la posibilidad de iterar. Además, puede cambiar la estructura de datos subyacente.

\textbf{Funcionalidad}: Se logra recorrer todas las ordenes de manera secuencial.
}
\assigns
\is{Steps}{IteradorConcreto}
\is{MainControler}{AgregadorConcreto}

\end{pattern}
\end{figure}

\begin{figure}[H]
\caption{Interfaces de las ordenes de ejecución para cada subsistema.}
\label{orden}
\begin{center}
\scalebox{.75}{
\begin{tikzpicture}\sf

\umlclass[type=abstract]{Orden}
{}
{
\umlvirt{ejecutar()}
}

\umlclass[below left=2cm and 4.5cm of Orden]{OrdenRotor}
{
OrdenRotor(i: Measure)
}
{
ejecutar()
}

\umlclass[below left=2cm and -1cm of Orden]{OrdenExtensor}
{
OrdenExtensor(i: Measure)
}
{
ejecutar()
}

\umlclass[below right=2cm and -1cm of Orden]{OrdenPinza}
{
OrdenPinza(i: Measure)
}
{
ejecutar()
}

\umlclass[below right=2cm and 4cm of Orden]{OrdenMultiple}
{
OrdenMultiple(i: OrdenRotor, \\ i: OrdenExtensor, \\i: OrdenPinza)

}
{
ejecutar()
}
\umlinherit[geometry=|-|]{OrdenRotor}{Orden}
\umlinherit[geometry=|-|]{OrdenExtensor}{Orden}
\umlinherit[geometry=|-|]{OrdenPinza}{Orden}
\umlinherit[geometry=|-|,arm1=2.54cm]{OrdenMultiple}{Orden}
\umluniaggreg[geometry=-|-, anchor1=east, arm1=1cm]{OrdenMultiple}{Orden}
\umlnote[above=4cm of OrdenMultiple,width=5cm]{OrdenMultiple}{
ejecutar() \{  \\
\ \ \ \ ordenRotor.ejecutar() \\
\ \ \ \ ordenExtensor.ejecutar() \\
\ \ \ \ ordenPinza.ejecutar() \\
\}
}

\end{tikzpicture}}
\end{center}
\end{figure}

\begin{figure}
\begin{lstlisting}[caption=Ejemplo de implementación del módulo OrdenRotor,label={ejemploOrdenRotor}]
void ejecutar {
    rotorController.setSetPoint(setPoint)
    rotorSensor.signal()
    rotorController.readConnection()
    rotorController.control()
}
\end{lstlisting}
\end{figure}


\begin{figure}[h]
\caption{Documentación de la aplicación del patrón Command para el desacople de ordenes a ejecutar en cada actuador del brazo en un paso.}
\label{docCommandSteps}
\begin{pattern}[]{Comando para manejar las acciones que deben ser ejecutadas en un paso en cada actuador.}{Algorithm}{idFigAlg}
\based{Orden (Command)}
\why{\textbf{Cambios previstos}: Las acciones a llevar a cabo para cada actuador pueden cambiar, se pueden agregar o quitar actuadores.

\textbf{Funcionalidad}: Se logra ejecutar una acción sobre todos los actuadores configurados con una sola acción del invocador.
}
\assigns
\is{Orden}{Orden}
\is{OrdenRotor}{OrdenConcreta}
\is{OrdenExtensor}{OrdenConcreta}
\is{OrdenPinza}{OrdenConcreta}
\is{OrdenMultiple}{OrdenConcreta}
\is{MainController}{Invocador}
\is{RotorController}{Receptor}
\is{ExtensorController}{Receptor}
\is{PinzaController}{Receptor}

\end{pattern}
\end{figure}


Se tiene un iterador de ordenes \ref{iterator}, en particular múltiples, que almacena todos los pasos de ejecución que la función provista generará. Por lo que el \textit{MainController} podrá recorrerlos ejecutando cada orden de manera sencilla. Logramos, almacenar el procedimiento a realizar y desacoplar como se pone en marcha el ciclo de control en cada subsistema.

\begin{figure}[h]
\caption{Estructura del módulo MainController.}
\label{maincontroller}
\begin{center}
\scalebox{.75}{
\begin{tikzpicture}\sf
\umlclass[x=-5,y=0]{MainController}
{
MainContoller(i: StepsComputator)
}
{
graspAt(i: Coordenadas) \\
notifyReady() \\
notifyError() \\
changeState()
}
\umlclass[x=0,y=-4,type=abstract]{MainControllerState}
{}
{
\umlvirt{graspAt(i: Coordenadas)} \\
\umlvirt{notifyReady(i: MainCtrl)} \\
}
\umlclass[x=-10,y=-8]{MainWaiting}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}
\umlclass[x=-5,y=-8]{Main0}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}
\umlclass[x=0,y=-8]{Main1}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}
\umlclass[x=5,y=-8]{Main2}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}



\umlclass[x=3,y=0]{StepsComputator}
{
}
{
geneararStepts(i: Coordenadas) \\
}
\umluniaggreg{MainController}{StepsComputator}
\umluniaggreg[geometry=|-]{MainController}{MainControllerState}
\umlinherit[geometry=|-|]{MainWaiting}{MainControllerState}
\umlinherit[geometry=|-|]{Main0}{MainControllerState}
\umlinherit[geometry=|-|]{Main1}{MainControllerState}
\umlinherit[geometry=|-|]{Main2}{MainControllerState}
\umlnote[x=-9,y=-4,width=6.5cm]{MainController}
{
void notifyReady() \{ \\
\ \ \ \ mainControllerState.notifyReady() \\
\}
}


\end{tikzpicture}
}
\end{center}

\end{figure}

\begin{figure}[H]
\caption{Documentación de la aplicación del patrón \textit{State} para el manejo de ejecución de pasos completos.}
\label{docEstateMain}
\begin{pattern}[]{Estados de operación del controlador principal}{Algorithm}{idFigAlg}
\based{Estado (State)}
\why{\textbf{Cambios previstos}: El controlador principal llevará a cabo el control de los subsistemas de control, dependiendo del estado en el que se encuentre. Podrían cambiar el comportamiento requerido de algunos de los estados definidos o bien podría ser necesario agregar nuevos estados con sus correspondientes comportamientos.

\textbf{Funcionalidad}: Teniendo en cuenta que para poder ejecutar un nuevo paso se deben haber finalizado con éxito todas las operaciones sobre actuadores, se introducen estados por cada orden terminada, a fin de que solo al hacer una transición completa se puede ejecutar un nuevo paso.
}
\assigns
\is{MainController}{Contexto}
\is{MainControllerState}{Estado}
\is{MainWaiting}{EstadoConcreto}
\is{Main1}{EstadoConcreto}
\is{Main2}{EstadoConcreto}
\is{Main3}{EstadoConcreto}

\end{pattern}
\end{figure}
\FloatBarrier


Hasta la introducción de \textbf{MainController} todo lo que se hizo fue aplicar el concepto de subsistemas. Pero para poder cumplir los requerimientos particulares del ejemplo, es necesario introducir ciertos cambios. Como se debe ejecutar un paso a la vez, se tiene que esperar a que todas las ordenes enviadas en el paso anterior a los subsistemas se encuentren finalizadas. Para ello se hace uso del patrón \textit{state} (ver la documentación de la aplicación del mismo en \ref{docEstateMain}), al cual se le delegarán los métodos \verb|graspAt| y \verb|notifyReady|. La idea es cambiar el comportamiento de estos dependiendo de en qué estadio se encuentra el sistema. Es decir, por cada orden enviada y terminada se cambia de estado, llevando así una cuenta de la cantidad de acciones finalizadas. Solo cuando se llegue a las cuatro ordenes finalizadas se podrá ejecutar un nuevo paso. Esto se puede ver en el siguiente gráfico de estados \ref{statesMainController}.

\begin{figure}[H]
\caption{Transiciones de estados del MainController}
\label{statesMainController}
\begin{center}
\begin{tikzpicture}

\umlsimpleclass[fill=red!20,x=-2]{Waiting}
\umlsimpleclass[fill=red!20,x=2]{0}
\umlsimpleclass[fill=red!20,x=2, y=-2]{1}
\umlsimpleclass[fill=red!20,x=2, y=-4]{2}

\umltrans[arg=graspAt,pos=0.5]{Waiting}{0}
\umltrans[arg=notifyEnd,pos=0.5]{0}{1}
\umltrans[arg=notifyEnd,pos=0.5]{1}{2}
\umltrans[arg=notifyEnd,pos=1.5,arm1=3cm,geometry=-|-]{2}{0}

\end{tikzpicture}
\end{center}
\end{figure}

Por lo que, el estado \textit{Waiting} no implementa \verb|notifyOrder| y a su vez 0, 1 y 2 no implementan \verb|graspAt|. En cambio, \textit{Waiting} implementan \verb|graspAt| la cual computa los pasos y ejecuta el primero utilizando el iterator. Luego, por cada \verb|notifyEnd| los subsistemas le avisan al MainController que terminaron la orden y por cada una transaccionamos a un estado nuevo. Luego de que se ejecuta \verb|graspAt| se transiciona al estado 0 en el cual al recibir un \verb|notifyEnd| se transiciona a 1 y lo mismo hasta llegar a 2. En cambio, cuando estamos en el estado 2 y se ejecuta \verb|notifyEnd| lo que se hará es ejecutar un nuevo paso si en el iterador de pasos quedan pasos, en caso contrario se transicionará a \textit{Waiting} ya que se terminó la ejecución. Está claro que para poder llevar a cabo este comportamiento es necesario que los subsistemas respondan a las necesidades. Por lo que cada uno tendrá que llamar al método \verb|notifyEnd| del \textbf{MainController} cuando efectivamente terminen la ejecución de la orden, es decir, el ciclo de control. Para hacerlo se puede agregar la llamada en la cuando se decide transicionar de \textit{Moving} a \textit{Waiting} o en el caso de los subsistemas sin estados, luego de aplicar los cambios en los actuadores.

\subsubsection*{Conclusión}

La solución propuesta mejora varios aspectos a la que utiliza como criterio de división la funcionalidad. Por un lado, se anticipa a cambios probables tales como los de la tabla \ref{tablaConclu}.

\begin{table}[h]
\centering
\caption{Anticipos al cambio del diseño propuesto para el brazo robótico.}
\label{tablaConclu}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|p{3cm}|p{5cm}|p{8cm}|}
\hline
\textbf{Item de cambio}    & \textbf{Naturaleza del cambio}  & \textbf{Manejo del cambio}  \\ \hline
\textbf{Hardware}          &  
    - Agregar, quitar o modificar actuadores y sensores.
    
    - Cambios en la comunicación.
&  
Los subsistemas están desacoplados del control principal, permitiendo agregar, quitar o modificar componentes de manera independiente respetando las interfaces definidas.  
La modularización permite gestionar sensores, actuadores y comunicación por separado. La lógica de control puede modificarse fácilmente cambiando la implementación del módulo Algoritmo.
\\ \hline
\textbf{Lógica de control} &  
    - Cambios en decisiones de trabajo, como ejecución secuencial o criterios de avance.
&  
El comportamiento está encapsulado en módulos. La máquina de estados que controla la ejecución puede modificarse fácilmente agregando o editando estados en el iterador Steps.  
\\ \hline
\end{tabular}
}
\end{table}

Además, se fomenta la reutilización del código, permitiendo aplicar las soluciones existentes a distintos problemas. Cualquier modificación futura requerirá menos esfuerzo por parte de los desarrolladores, ya que el sistema será más fácil de comprender. La documentación también contribuye a esta facilidad de mantenimiento. Los cambios están encapsulados, por lo que el control de calidad se reduce a verificar módulos individuales y no secciones de código enteras.


\newpage





\section{Integridad de la información}

Douglass en \cite{douglass}, afirma que cuando se intenta construir software embebido es importante poner esfuerzo en garantizar de alguna manera las siguientes propiedades:

\begin{itemize}
\item Reliability (confiabilidad) en los sistemas embebidos se refiere a la capacidad del sistema de operar de manera continua y correcta durante un período de tiempo determinado, sin fallos que interrumpan su funcionamiento. Es fundamental porque muchos sistemas embebidos, como los que controlan robots, vehículos o dispositivos médicos, deben garantizar la ejecución exitosa de sus tareas bajo condiciones normales o adversas. Una alta confiabilidad se traduce en una mayor disponibilidad del servicio, menor tasa de fallos y una experiencia más segura para los usuarios.

\item Safety (seguridad) es igualmente crucial en sistemas embebidos, ya que garantiza que el sistema no genere riesgos inaceptables para personas, equipos o el entorno. No basta con que el sistema funcione correctamente; debe hacerlo de manera que prevenga accidentes, daños físicos o pérdidas. Esto implica identificar peligros potenciales, estimar su riesgo (producto de su severidad y probabilidad) y diseñar mecanismos de mitigación adecuados, como pasar a estados seguros ante fallos o suministrar información confiable a operadores. En aplicaciones críticas, como aeronáutica, medicina o automatización industrial, la seguridad es un requisito esencial porque cualquier error puede tener consecuencias graves e irreversibles.
\end{itemize}

Además, agrega que uno de los origenes más comunes de inconvenientes relacionados fallas de seguridad o confiabilidad es la corrupcion de la información. Un pulso electromagnético o fallas en el hardware pueden causar daños en la información dejándola comprometida, por ejemplo un \gls{bit} o perdida parcial de cierta zona de la memoria. Si los datos afectados son críticos el problema puede derivar en un error grave del sistema. Para hacer frente a esto existen diferentes técnicas, desde calcular \textit{checksums} con la intención de verificar integridad hasta almacenar la información múltiples veces creando \textbf{redundancia}. En el libro, Douglass propone el uso de dos estrategias, una para datos que ocupan mucha memoria y otra para pequeños valores.

Estas estrategias suelen ser agregadas al código modificando la implementación de los métodos del módulo encargado de almacenar la informacion, o agregando verificaciones en las partes del código que la utilizan. Es decir, si por ejemplo se utiliza el módulo \textbf{Data} (ver figura \ref{dataInter}) se realiza \verb|data = data.getData()| para obtener el valor y luego se ejecutan las validaciones necesarias para verificar la integridad del mismo. 
Esto último provoca código repetido en cada llamado a \verb|getData()| y a su vez ante cualquier cambio en el dato, la estrategia de validación utilizada puede dejar de ser aplicable, obligando a modificar múltiples porciones de código.

\begin{figure}[H]
\caption{Interfaz del módulo Data,}
\label{dataInter}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Data}
{
value: dato \\
invertedValue: dato
}
{
    getData(): dato \\
    setData(i: dato) \\
    invert()
}

\end{tikzpicture}
\end{center}
\end{figure}

Desde el punto de vista del diseño de software se puede aportar una mirada crítica hacia las propuestas el libro \cite[pág. 357]{douglass}, dado que plantean modificar la interfaz e implementación de los módulos encargados de almacenar la información con el objetivo de añadir esta ``capa'' de verificación. Es decir que los módulos no solo oculten como se almacena la información sino que se encarguen de verificar su integridad. 

En cambio, una posible forma de solucionar esto desde el diseño orientado al cambio es utilizar el patrón \textit{Decorator} que nos permite añadir y remover de manera dinámica funcionalidades. En este caso, la capacidad de verificar la información. Otra ventaja, además de poder hacerlo de manera dinámica, es que mantenemos separadas las responsabilidades de cada módulo. A diferencia de los propuesto en el libro, no se combina el almacenaje de la información con su verificación, de manera que cada porción puede ser implementada de manera independiente. La solución se muestra en el gráfico \ref{decorator} con su correspondiente documentación en \ref{docDecorator}.

\begin{figure}[h]
\caption{Ejemplo de aplicación del patrón \textit{Decorator} para garantizar la integridad de la información.}
\label{decorator}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Data}
{}
{
    getData(): dato \\
    setData(i: dato)
}
\umlclass[right=3cm of Data]{CRCData}
{
    calculatedCrc: crc
    errorHandler: errorHandler
}
{
    getData(): dato \\
    setData(i: dato) \\
    calcularCrc(i: dato) \\
    setErrorHandler(i: errorHandler)
}

\umlinherit{Data}{CRCData}
\umluniaggreg[anchor1=-170, anchor2=-24]{CRCData}{Data}

\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}[H]
\caption{Documentación de la aplicación del patrón \textit{Decorator} al caso de verificación de la integridad de la información.}
\label{docDecorator}
\begin{pattern}[]{Modulo decorador que extiende dinámicamente las funcionalidades de otro módulo sin cambiar la implementación.}{Algorithm}{idFigAlg}
\based{Decorador (Decorator)}
\why{\textbf{Cambios previstos}: Pueden agregarse y quitarse métodos de verificación.

\textbf{Funcionalidad}: Antes de devolver la información se realiza una verificación de la integridad de la información almacenada.
}
\assigns
\is{Data}{ComponenteConcreto}
\is{CRCData}{DecoradorConcreto}

\end{pattern}
\end{figure}


\begin{lstlisting}[caption=Ejemplo de implementación métodos setData y getData del módulo CRCData.,label={codDeco},style=seudocode]
setData(i: dato){
    calculatedCrc = calcularCrc(i)
    data.setData(dato)
}

getData() {
    dato = data.getData()
    if calculateCrc(dato) == calculatedCrc
        return dato
    else
        errorHandler()
}
\end{lstlisting}

En la figura \ref{codDeco} se observa un ejemplo de implementación de los métodos \verb|setData| y \verb|getData|. En el cual, se utiliza el método \verb|calcularCrc| para obtener el código de detección de errores de tamaño fijo basado en un polinomio cíclico. Entonces, comparando el código calculado cuando se guardo la información con el calculado en el momento de obtenerla se puede saber si la información está o no corrupta. 

De esta forma, aplicando el patron \textit{decorator} se logra añadir una capa de protección a la integridad de la información, a su vez permite combinar diferentes técnicas usando este patrón.


\section{Organización de la ejecución}
\label{orgEjecucion}

En un sistema robótico embebido se suelen ejecutar múltiples tareas para lograr un cierto objetivo. Ya sea, si se eligió una arquitectura de diseño de tipo ``Control de procesos'' o no, por lo general se debe verificar información recibida a través de sensores y otras fuentes (comunicación serial, web, etc), realizar cómputos y efectuar acciones con los actuadores presentes en el sistema en tiempo real.

Una implementación simple para realizar el comportamiento mencionado, consite en crear funciones para cada parte del proceso y llamarlas en \textit{loop} desde la función \textit{main}, y si es necesario añadir un tiempo de espera entre cada ejecución mediante \textit{sleeps}. La principal desventaja que conlleva este enfoque es que los sistemas robóticos son en tiempo real, es decir, por ejemplo se pueden perder \textit{inputs} de sensores si no se los maneja de manera correcta. Además, los tiempos de espera son bloqueantes por lo que se desperdicia acceso a computo.

Una estrategia que logra mejorar estos puntos consta de hacer uso de las interrupciones del microcontrolador permitiendo atender a todos los \textit{inputs} y eventos del mundo real. En el robot desmalezador \cite{paperPomponio} se utiliza esta estrategia en conjunto con una \nameref{arqControlProc}, por lo tanto existen 3 tareas principales:

\begin{itemize}
    \item Recibir información de los sensores y de la PC (por ejemplo, a traves del puerto serial).
    \item Procesar la información recibida y decidir que valores aplicar en los actuadores.
    \item Aplicar los nuevos valores a los actuadores. Notar que no es tan simple como configurar un número y dejar que actúe, en muchos casos se necesita un seguimiento durante el tiempo.
\end{itemize}

De las tareas que se tienen, dos deben ser llamadas por el sistema y la otra (recibir información) en muchos casos se dará en forma de interrupciones que el sistema debe atender. Ya se comentó de ese proceso en la sección \nameref{obtInfo}, solo es importante recordar que la estructura propuesta provee una interfaz la cual se puede invocar para obtener la información recibida de manera simple. Una vez resuelta esa cuestión ahora se debe ejecutar las otras dos tareas, dado que se quieren hacer los ajustes cada determinado tiempo, se propone crear una nueva interrupción que sea disparada de manera periódica y que su \textit{handler} se encargue de realizar todo el proceso de control y cálculo. En el manejo de esa interrupción, se accederá a la interfaces propuestas para obtener información de los sensores. Y por último, para los actuadores que necesitan un seguimiento temporal para su control, se agrega una nueva interrupción que puede ser individual para el actuador y el tiempo de disparo puede estar determinado de manera particular.

Tener interrupciones periódicas puede general una bola de nieve de ejecución si el manejo de una tarda más que el tiempo entre disparos. Para prevenirlo se propone aplicar el patrón \textit{State}, haciendo que cuando se comience a manejar la interrupción cambie el estado y toda nueva llamada al \textit{handler} resulte en un retorno rápido (solo \textit{return}). Una vez terminada la ejecución de este ciclo se cambia el estado otra vez permitiendo la ejecución de nuevos llamados. Un ejemplo de la estructura de módulos subyacente a esta solución es la que se puede ver en la figura \ref{estructuraInterrup}, seguida de la documentación del uso del patrón \textit{State}.

\begin{figure}[H]
\caption{Ejemplo de handler usando \textit{State} con su correspondiente documentación.}
\label{estructuraInterrup}
\begin{center}
\begin{tikzpicture}\sf


\umlclass[type=abstract]{State}
{
}
{
    \umlvirt{handInterruption()} \\
}

\umlclass[left=2cm of State]{InterruptionHandler}
{
}
{
    handInterruption() \\
    changeState(i: State)
}

\umlclass[below left=2cm and -1cm of State]{Working}
{
}
{
    handInterruption() \\
}

\umlclass[below right=2cm and -1cm of State]{Waiting}
{
}
{
    handInterruption() \\
}

\umlnote[above right=1cm and -1.5cm of Waiting]{Waiting}{
handInterruption() \{ \\
\ \ \ \ return()\\
\}
}

\umlnote[left=1.5cm of Working,width=4cm]{Working}{
handInterruption() \{ \\
\ \ \ \ \textit{comportamiento}\\
\}
}


\umluniaggreg{InterruptionHandler}{State}
\umlinherit[geometry=|-|]{Working}{State}
\umlinherit[geometry=|-|]{Waiting}{State}



\end{tikzpicture}
\end{center}


\begin{pattern}[]{Control de manejo de interrupciones}{Algorithm}{idFigAlg}
\based{State (Estado)}
\why{\textbf{Cambios previstos}: Agregar, quitar o editar estados de manejo de la interrupción.

\textbf{Funcionalidad}: Configura el estado actual de manejo de una interrupción a fin de que una interrupción corte la ejecución de otra.
}
\assigns
\is{InterruptionHandler}{Contexto}
\is{State}{Estado}
\is{Working}{EstadoConcreto}
\is{Waiting}{EstadoConcreto}

\end{pattern}

\end{figure}


Notar que esta estrategia explota la capacidad de manejar interrupciones del microcontrolador, por lo tanto es necesario que este las soporte para llevarla a cabo.

Al aplicar el suo de interrupciones junto con patrones de diseño como State, el sistema embebido de control robótico adquiere una estructura más robusta, eficiente y mantenible. Se logran superar las limitaciones del enfoque secuencial simple, evitando la pérdida de información crítica proveniente de sensores y eliminando los tiempos de espera bloqueantes. Además, la modularización del comportamiento en tareas bien definidas, combinada con la sincronización mediante interrupciones periódicas y específicas, permite un control más preciso y en tiempo real de los actuadores. Este enfoque no solo mejora la capacidad de respuesta del sistema, sino que también facilita la extensión y modificación del software frente a nuevos requerimientos, en línea con los principios del diseño orientado al cambio.

