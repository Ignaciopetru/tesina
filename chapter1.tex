% From mitthesis package
% Version: 1.07, 2024/09/26
% Documentation: https://ctan.org/pkg/mitthesis


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{CadetBlue!15!white},   
    commentstyle=\color{Red3},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{Blue3},
    basicstyle=\small\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C,
    basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}%
\lstset{language=C++,style={mystyle}}%

\lstdefinestyle{seudocode}{
    backgroundcolor=\color{Goldenrod!30!white},   
    commentstyle=\color{Red3},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{Blue3},
    basicstyle=\small\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C,
    basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}%


\chapter{Problemas comunes}
\label{problemasComunes}

En este capítulo se enumeran problemas comunes en el desarrollo de software embebido de control, extraídos principalmente del libro ``\textit{Design Patterns for Embedded Systems in C: An Embedded Software Engineering Toolkit}'' \cite{douglass}. Además, se analiza la solución de diseño propuesta en ese libro y, a su vez, se intenta aportar otra desde la perspectiva de la IS enfocada en el diseño para el cambio. En muchos casos, se identifica la posibilidad de aplicar ciertos patrones de diseño de \cite{Gamma:1995:DPE:186897}, mientras que en otros se utilizan conceptos y metodologías clave del diseño para el cambio, propuestos por David L. Parnas \cite{Parnas02, Parnas1972, parnas1977abstract}.


\minitoc



\section{Acceso al hardware}
\label{Accesoalhardware}
Una de las características distintivas de los sistemas embebidos es que trabajan directamente con dispositivos de hardware. Cada uno de estos tiene sus propios protocolos de comunicación y estándares de funcionamiento (por ejemplo, direcciones de memoria, codificación de bits, etc), por lo tanto el software se debe ajustar a sus requerimientos. Como se puede entender esta tarea no es simple y puede demandar mucho esfuerzo cada vez que se quiera modificar o agregar un componente de hardware. A su vez, puede que múltiples módulos de un sistema embebido quieran acceder al dispositivo, por lo que cada uno debe encargarse de la comunicación creando código repetido y complicando aún más las modificaciones. 

Para entender los inconvenientes que puede conllevar no diseñar pensando en el cambio veamos un ejemplo simple. Suponga que se tiene un sistema embebido que debe controlar un motor de corriente continua (\gls{DC}) y que el software para hacerlo corre en un microcontrolador de la empresa \gls{arduinoEmpre}. Los requerimientos definen que es necesario poder asignar el sentido y la velocidad de rotación del motor según se necesite. Para controlar el motor se utiliza un módulo \gls{DRV8838}, el cual se coloca entre el microcontrolador y el motor. Es necesario ya que el microcontrolador y su plataforma no pueden manejar las potencias necesarias para hacer funcionar el dispositivo. Podemos ver el conexionado del mismo en la figura \ref{drv8838}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.65\linewidth]{drv8838.png}
    \caption{Conexionado módulo DRV8838}
    \label{drv8838}
\end{figure}

Notemos que el \gls{DRV8838} tiene 3 pines de control, \textit{ENABLE}. \textit{PHASE} y \textit{SLEEP} pero solo utilizaremos los 2 primeros para simplificar el ejemplo. De todas formas, en esta tabla \ref{funciones_pin_drv8838} podemos ver la función de cada pin.


\begin{table}[h]
\centering
\begin{tabular}{lllll}
\cline{1-3}
\multicolumn{1}{|l|}{PHASE}  & \multicolumn{1}{l|}{direccion de rotacion} & \multicolumn{1}{l|}{digital}   &  &  \\ \cline{1-3}
\multicolumn{1}{|l|}{ENABLE} & \multicolumn{1}{l|}{velocidad de rotación} & \multicolumn{1}{l|}{analogico} &  &  \\ \cline{1-3}
\multicolumn{1}{|l|}{SLEEP}  & \multicolumn{1}{l|}{liberar fuerza}        & \multicolumn{1}{l|}{digital}   &  &  \\ \cline{1-3}
                             &                                            &                                &  & 
\end{tabular}
\caption{Funciones de cada pin del módulo DRV8838}
\label{funciones_pin_drv8838}
\end{table}

Por lo tanto, con los dos primeros pines podremos cumplir los requerimientos mencionados. Tendremos dos cables conectados al \gls{microcontrolador}, uno que se dirige a \textit{ENABLE} y otro a \textit{PHASE}. En el código \ref{listing1} se encuentran las lineas necesarias para poder configurar el motor para luego poder utilizarlo como en los códigos \ref{codigoMax} y \ref{codigoDet}. Las funciones \verb|pinMode|, \verb|digitalWrite| y \verb|analogWrite| son provistas por el entorno de desarrollo de Arduino. Sus nombres son bastastantes descriptivos de su comportamiento, \verb|pinMode| configura el modo de operacion de un PIN en particular, puede ser \verb|OUTPUT| o \verb|INPUT|. Y tanto \verb|digitalWrite| como \verb|analogWrite|, escriben en un PIN el valor especificado.

\begin{lstlisting}[caption=Configuración inicial del control del motor paso a paso.,label={listing1}]
# Notar que los numeros asignados a los pines son arbritarios dentro del conjunto de pines disponibles en nuestro Aruino.

# Constantes globales
const int DIR_pin = 7;
const int VEL_pin = 9;

void setup() {
     .
     .
     .
  pinMode(DIR_pin, OUTPUT);
  pinMode(VEL_pin, OUTPUT);
     .
     .
     .
}
\end{lstlisting}

\begin{lstlisting}[caption=Configurar 
máxima velocidad giro en sentido horario.,label={codigoMax}]
digitalWrite(DIR_pin, HIGH);
analogWrite(VEL_pin, 255); # Maximo valor aceptado, PWM siempre encendido
\end{lstlisting}

\begin{lstlisting}[caption=Detener giro del motor paso a paso., label={codigoDet}]
analogWrite(VEL_pin, 0);
\end{lstlisting}

No es necesario entender por completo que hace cada llamada, pero si es importante comprender que es necesario ejecutar ese código para controlar el motor. Es decir, que si cualquier cliente (se supone que ya definimos que es cliente) del motor en nuestro sistema deberá saber que para hacer que el motor vaya hacia adelante a la mayor velocidad posible es necesario ejecutar las dos funciones indicadas sobre los pines correspondientes al motor. Un pequeño ejemplo podría ser el siguiente \ref{listingMotor}, en el cual se consulta una bandera asociada al estado de un valor y en base a este se acciona el motor.

\begin{lstlisting}[caption=Ejemplo uso del motor paso a paso.,label={listingMotor}]
    .
    .
    .
if (valor > 100) {
    digitalWrite(DIR_pin, HIGH);
    analogWrite(VEL_pin, 255);
} else {
    analogWrite(VEL_pin, 0);
}
    .
    .
    .
\end{lstlisting}

¿Qué problemas tiene esta estrategia de cara al cambio?
\begin{itemize}
    \item Hace que el código sea poco evidente, es decir, no es fácil saber de que se trata una cierta porción de código con solo leerlo. Y por lo tanto provoca que sea difícil de modificar, requiere un trabajo extra de entendimiento antes de poder aplicar cualquier cambio.
    \item Imagine el caso en el que por cierto motivo se debe invertir el sentido de giro del motor, de manera que lo que era ir hacia adelante ahora es hacia atrás. Para llevar a cabo el cambio, debemos modificar todas las llamadas a \verb|digitalWrite(DIR_pin, | cambiando \verb|HIGH| por \verb|DOWN| y viceversa. Es fácil cometer un error y dejar al sistema en un estado inconsistente.
    \item Ahora, qué pasa si tenemos que agregar un segundo motor del mismo tipo con el mismo controlador? Ya sea por duplicación de la potencia o un motor que cumpla otra función en el sistema. En el código tenemos que declarar nuevamente 2 constantes (suponga \verb|DIR_pin2| y \verb|VEL_pin2|, una para cada nuevo pin de control, también debemos setear esos pines como \verb|OUTPUT| y ahora en diferentes partes del código tendremos llamadas a \verb|digitalWrite| y \verb|analogWrite| sobre diferentes pines lo cual es cada vez más confuso.
    \item Por cierto motivo se descompuso el controlador del motor, y no se consigue un reemplazo idéntico, sino que se adquiere un nuevo controlador de otra marca, por ejemplo, un \textit{Pololu Simple Motor Controller G2}. En este caso, este controlador no utilizar la misma interfaz de control que el DVR8838, sino para controlarlo hay que acceder a el mediante comunicación serial (utiliza un solo pin especifico). Incluso utilizando las herramientas provistas por el entorno de Arduino, el código no es similar \ref{listingDistinto}.
    \begin{lstlisting}[caption=Configuración del motor paso a paso que utiliza comunicación serie., label={listingDistinto}]
        void set_up() {
            .
            .
            .
            Serial.begin(9000);
            .
            .
            .
        }
    \end{lstlisting}
    \begin{lstlisting}[caption=Máxima velocidad giro horario]
        Serial.write(0xAA);
        Serial.write(0x0C);
        Serial.write(0x85);
        Serial.write(0x7F);
    \end{lstlisting}
    \begin{lstlisting}[caption=Detenerse]
        Serial.write(0xAA);
        Serial.write(0x0C);
        Serial.write(0xE0);
    \end{lstlisting}
    Por lo tanto debemos modificar todos los usos de la antigua implementación por la nueva, lo cual además requerir un esfuerzo considerable, da pie a errores y obliga a re-probar código que ya se sabia que funcionaba correctamente.
\end{itemize}

Todos estos inconvenientes son derivados de que el \textit{hardware} comprende un ítem de cambio frecuente; por lo que si seguimos la metodología de Parnas (ver \ref{metoParnas}), debemos asignarle un módulo \ref{interfazMotor}. Este es una representación virtual de hardware que debe proveer una interfaz lo suficientemente insensible a la implementación. Es decir, debemos pensar en lo que, en este caso, el motor siempre va a hacer independientemente de los posibles cambios que sufra el hardware subyacente. Como afirma Parnas en \cite{Parnas02, parnas1977abstract}, debemos construir interfaces con la cantidad de mínima de métodos del modo más abstracto posible, sin agregar métodos que puedan ser reemplazados utilizando otros ya definidos, \textit{abstracción} y \textit{encapsulando} con el objetivo de ocultar la implementación.
Un motor DC siempre recibirá ordenes para definir su sentido y velocidad de rotación. Veamos como podemos definir este módulo y que ventajas nos trae hacerlo.

\begin{figure}
\caption{Interfaz MotorDC}
\label{interfazMotor}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=-3]{MotorDC}
{
MotorDC(i: int, i: int)
}
{
    
    setDir(i: Dir) \\ 
    setVel(i: int) \\
}
\end{tikzpicture}
\end{center}
\end{figure}

Donde los parámetros del constructor \verb|MotorDC| son los pines de control, el parámetro de \verb|set_dir| es de tipo \verb|Dir| el cual es un int que puede tomar dos valores uno para el sentido de giro horario y otro anti-horario y por último el input de \verb|setVel| es un int entre 0 y 255 que representa la velocidad porcentual. Veamos en el ejemplo \ref{constructorMotor} una posible implementación de esta interfaz utilizando el controlador DVR8838.

\begin{lstlisting}[caption=Posible implementación de la interfaz del módulo MotorDC.,label={constructorMotor}]
void MotorDC(int dir_pin, int vel_pin) {
    this->dir_pin = dir_pin;
    this->vel_pin = vel_pin;
    pinMode(this->dir_pin, OUTPUT);
    pinMode(this->vel_pin, OUTPUT);
}

void set_dir(Dir dir) {
    if (dir == Dir.HORARIO) {
        digitalWrite(DIR_pin, HIGH);
    } else {
        digitalWrite(DIR_pin, DOWN);
    }
}

void setVel(int vel) {
    if vel > 0 && vel <= 255 {
        analogWrite(VEL_pin, vel);
    }
}
\end{lstlisting}

Ya son evidentes las primeras ventajas, es mucho más claro en el código \ref{ejeploUsoMotor}

\begin{lstlisting}[caption=Ejmplo de uso de la interfaz del módulo MotorDC, label={ejeploUsoMotor}]
	motor = MotorDC(1, 2)
    motor->setDir(Dir.HORARIO)
    motor->setVel(255)
\end{lstlisting}

Además si debemos modificar el sentido de giro es tan fácil como cambiar el método \verb|setDir|, los clientes no notarán el cambio. A su vez, si queremos controlar otro motor podemos hacerlo como en \ref{ejemploOtroMotor}. 

\begin{lstlisting}[caption=Ejemplo control motor paso a paso comunicación serie.,label={ejemploOtroMotor}]
    MotorDC motor_delantero = MotorDC(18, 19)

    motor_delantero->setDir(Dir.ANTIHORARIO)
    motor_delantero->setVel(10)
\end{lstlisting}

Y para un cambio de componente, como el explicado anteriormente, los clientes del módulo lo ignoraran, ya que sera prácticamente la misma (a menos un cambio en el constructor, donde ya no se necesitaran los pines). Por ejemplo, ahora \verb|setDir| será definida como en el listing \ref{nuevaSetDir}.

\begin{lstlisting}[caption=Implementación método setVel para el motor que utiliza comunicación serie.,label={nuevaSetDir}]
void setVel(vel: int) {
    if vel > 0 && vel <= 255 {
        this->serial.write(0xAA);
        this->serial.write(0x0C);
        hex_vel = int_to_hex(vel)
        this->serial.write(hex_vel);
    }
}
\end{lstlisting}

Aún podemos mejorar el diseño haciendo uso del concepto de herencia de interfaz (explicado en la sección \ref{ingso}). Esto nos permitirá reutilizar módulos ya implementados y abstraer aun más a los clientes de la implementación. Para hacerlo se define un módulo \textbf{MotorDC} abstracto del cual hereda la interfaz cada modelo o combinación de motor y controlador. En este caso la estructura es la de la figura \ref{estructuraHerencia}.

\begin{figure}
\caption{Módulo MotorDC abstracto y estructura de herencia.}
\label{estructuraHerencia}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=0,type=abstract]{MotorDC}
{}
{
    \umlvirt{setDir(i: Dir)} \\ 
    \umlvirt{setVel(i: int)} \\
}

\umlclass[x=-3, y=-4]{MotorDCDVR8838}
{
	MotorDC(i: int, i: int)
}
{
    setDir(i: Dir) \\ 
    setVel(i: int) \\
}
\umlclass[x=3, y=-4]{MotorDCG2}
{
	MotorDC(i: Serial)
}
{
    setDir(i: Dir) \\ 
    setVel(i: int) \\
}
\umlinherit[geometry=|-|]{MotorDCDVR8838}{MotorDC}
\umlinherit[geometry=|-|]{MotorDCG2}{MotorDC}
\end{tikzpicture}
\end{center}
\end{figure}

El cliente no tiene noción con cual de los dos tipos de controladores esta tratando, solo llama a las funciones provistas. También es posible agregar mas herederos para cada modelo de controlador/motor, y reutilizar las módulos implementados en caso de utilizar hardware idéntico. 

De esta manera seguimos las prácticas recomendadas en la IS \cite{ShawGarlan1996, ghezzi2003, bass2003, DBLP:books/daglib/0030743} y logramos un diseño orientado al cambio \cite{Gamma:1995:DPE:186897}.

\section{Interfaces que no se ajustan perfectamente}
Muchas veces el proveedor del hardware incluye con este librerías para su control, otras veces se consiguen en internet o en previos proyectos. El problema recae en que estas interfaces pueden no ajustarse a las expectativas del sistema, generando la necesidad de ajustar la implementación de múltiples módulos. El hecho de que no se ajusten al sistema no quiere decir que este último este mal diseñado o que las interfaces lo estén. Simplemente puede ocurrir que se diseñaron teniendo en cuenta diferentes puntos de vista, probablemente influenciados por los requerimientos particulares.

Veamos un ejemplo, supóngase que un cierto sistema embebido está utilizando un display de 7 segmentos de 4 dígitos para mostrar la temperatura de funcionamiento y posición en grados de cierto actuador, como el de la imagen \ref{fig:enter-label}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{display.png}
    \caption{Display 7 segmentos 4 digitos}
    \label{fig:enter-label}
\end{figure}

Este display recibe la información utilizando comunicación en serie, con un protocolo propio del fabricante. Para facilitar su uso, este brinda una librería que implementa la comunicación y provee funciones simples de usar, tales como \verb|escribir(i: str): bool| y \verb|limpiar()|. La primera intenta escribir la cadena de caracteres indicada, pero solo lo hace si el display no está mostrando nada. En ese caso devuelve \verb|True| indicando que la acción fue completada con éxito, en caso contrario, es decir el display está mostrando texto al momento de llamar la función, retorna \verb|False|. \verb|limpiar()|, siempre limpia el display. Por lo tanto, se implementó el sistema utilizando las funciones provistas para comunicarse, múltiples módulos llaman esas funciones.

En cierto momento el módulo display dejó de funcionar y se lo reemplazó por otro de un fabricante distinto, que funciona con otro protocolo de comunicación. De la misma manera, la empresa provee una librería para utilizar el display. Pero la interfaz no es la misma que la anterior e incluso algunos comportamientos son diferentes. Por ejemplo, en la primer librería el método de escritura devolvía \verb|False| si se quería escribir y ya estaba mostrándose algo en el display, en la nueva si el display está mostrando algo el texto es pisado al momento de imprimir. Pero, provee un nueva método para verificar qué es lo que se está mostrando en el momento en que es invocada \verb|get_current(): str|.

Entonces, para hacer uso del nuevo display tradicionalmente se modifican todas las llamadas a las viejas funciones alrededor de todo sistema agregando la lógica nueva, como en el código \ref{cambiosAdapter}. El cambio puedo parecer no muy profundo, pero se debe tener en cuenta que con los nuevos cambios es necesario recopilar \textbf{todos} los usos de la librería, actualizarlos a mano y re-verificarlos. Además, este es un ejemplo simple, en el mundo real los cambios pueden ser mucho más complicados en su lógica y de diferente naturaleza. La configuración inicial del diseño es la que se muestra en \ref{configOri}. Es decir, la solución tradicional es no tener en cuenta el cambio en el diseño, lo que provoca las desventajas comentadas.

\begin{lstlisting}[label={cambiosAdapter}, caption=Ejemplo de modificaciones necesarias para adaptar la nueva librería.]
libAcme = LibAcme()
libEmca = LibEmca()


// Con ACME

if libAcme.escribir("Hola mundo!") {
	print("El display estaba vacio, se pudo escribir el nuevo texto.")
} else {
	print("El display esta ocupado mostrando algo, no se pudo escribir")
}

// Con EMCA

if libEmca.get_current() == "" {
	libEmca.imprimir("Hola mundo!")
	print("El display estaba vacio, se pudo escribir el nuevo texto.")
} else {
	print("El display esta ocupado mostrando algo, no se pudo escribir")
}


\end{lstlisting}


\begin{figure}[!h]
\caption{Configuración original del controlador del display.}
\label{configOri}
\begin{center}
\begin{tikzpicture}\sf
\umlsimpleclass[]{Cliente}

\umlclass[right=1.5cm of Cliente]{ControlAcme}
{}
{
escribir(i: str): bool  \\
limpiar()
}

\umluniassoc[]{Cliente}{ControlAcme}

\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}[h!]
\caption{Configuración utilizando los conceptos de la sección anterior \ref{Accesoalhardware}.}
\label{configUsando}
\begin{center}
\begin{tikzpicture}\sf
\umlsimpleclass[]{Cliente}

\umlclass[right=1.5cm of Cliente,type=abstract]{ControlDisplay}
{}
{
\umlvirt{escribir(i: str): bool}  \\
\umlvirt{limpiar()}
}

\umlclass[right=0.5cm of Cliente,below=2cm of Cliente]{ControlAcme}
{}
{
escribir(i: str): bool  \\
limpiar()
}

\umluniassoc[]{Cliente}{ControlDisplay}
\umlinherit[geometry=|-|]{ControlAcme}{ControlDisplay}


\end{tikzpicture}
\end{center}
\end{figure}

\newpage

Para construir un diseño orientado al cambio, primero se aplican los conceptos vistos en la sección \nameref{Accesoalhardware}, logrando el diseño \ref{configUsando}. Luego, para permitir el cambio propuesto sin tener que realizar todas las modificaciones mencionadas, se propone aplicar el patrón \textit{Adapter}, creando un módulo intermedio con la misma interfaz que \textbf{DisplayLib}. El cual utiliza los métodos provistos por la librería que encapsula el display con el objetivo de proveer la misma interfaz que la librería original. Podemos ver la nueva estructura en \ref{configNueva} y su debida documentación de aplicación del patrón en \ref{docAdapter}.

\begin{figure}[h!]
\caption{Nueva configuración utilizando el patrón \textit{Adapter}.}
\label{configNueva}
\begin{center}
\begin{tikzpicture}\sf
\umlsimpleclass[x=-4.5,y=1]{Cliente}

\umlclass[x=0,y=1,type=abstract]{ControlDisplay}
{}
{
\umlvirt{escribir(i: str): bool}  \\
\umlvirt{limpiar()}
}
\umlclass[x=-2.5,y=-3]{ControlAcme}
{}
{
escribir(i: str): bool  \\
limpiar()
}
\umlclass[x=2.5,y=-3]{ControlEmca}
{}
{
escribir(i: str): bool  \\
limpiar()
}
\umlclass[x=8,y=0.5]{LibEmca}
{}
{
imprimir(i: str)  \\
get\_current(): str
}
umluniassoc
\umlinherit[geometry=|-|]{ControlAcme}{ControlDisplay}
\umlinherit[geometry=|-|]{ControlEmca}{ControlDisplay}
\umluniassoc[]{Cliente}{ControlDisplay}
\umluniassoc[geometry=-|-]{ControlEmca}{LibEmca}
\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}[h!]
\caption{Documentación de la aplicación del patrón Adapter al ejemplo del display.}
\label{docAdapter}
\begin{pattern}[]{Adaptar nuevo controlador de display}{Algorithm}{idFigAlg}
\based{Adaptador (Adapter)}
\why{\textbf{Cambios previstos}: Se pueden agregar diferentes displays pero manteniendo una interfaz común.

\textbf{Funcionalidad}: En caso de agregar un nuevo display que provee una intefaz diferente a la utilizada en el sistema, se crea un módulo que la adapta para que corresponda a la usada.
}
\assigns
\is{ControlDisplay}{Target}
\is{LibEmca}{Adaptee}
\is{ControlEmca}{Adapter}
\end{pattern}
\end{figure}

Por lo tanto el cliente sigue utilizando la misma interfaz para acceder al display, reduciendo la cantidad y complejidad de los cambios necesarios para utilizar el nuevo display. Con esta solución se obtienen las siguientes ventajas:

\begin{itemize}

\item Facilitar la sustitución de hardware: permite cambiar el display sin necesidad de modificar el código del cliente, reduciendo el impacto del cambio de hardware en el sistema.

\item Mantiener la coherencia en la interfaz: el cliente sigue interactuando con la misma interfaz abstracta (\textit{ControlDisplay}), evitando la necesidad de modificar múltiples módulos en el sistema.

\item Minimizar el riesgo de errores: al encapsular las diferencias de implementación en el adaptador (\textbf{ControlEmca}), se reduce la posibilidad de introducir errores al modificar manualmente todas las llamadas en el código.

\item Mejorar la mantenibilidad: cualquier nuevo display con una interfaz distinta solo requiere la creación de un nuevo adaptador.

\item Se promueve la reutilización de código: la abstracción permite reutilizar la lógica del cliente sin importar qué display se use, evitando la duplicación de código y mejorando la modularidad.
\end{itemize}


En este ejemplo, una posible implementación para las funciones \verb|escribir(i: str): bool| y \verb|limpiar()| del módulo \textbf{ControlEmca} es la del código \ref{codigoAdapter}.

\begin{lstlisting}[label={codigoAdapter}, caption=Ejemplo implementación módulo ControlEmca.]
bool escribir(char* cadena) {
    if (libEmca.get_current() != "") {
        return False;
    }
    libEmca.imprimir(cadena);
    return True;
}

void limpiar() {
    libEmca.imprimir("");
}
\end{lstlisting}


\section{Control en conjunto de dispositivos}
Muchas aplicaciones embebidas robóticas controlan \gls{actuadores} que deben trabajar en conjunto para lograr el efecto deseado. Por ejemplo, para lograr el movimiento coordinado de un brazo robótico con múltiples articulaciones, todos los motores deben trabajar a la par. De manera similar, el uso de propulsores en una nave espacial en tres dimensiones requiere que muchos de estos dispositivos actúen en el momento preciso y con la cantidad correcta de fuerza para lograr la estabilización de la actitud. En ambos casos existe comunicación entre todos los componentes, ya sea para encadenar la ejecución de ciertos movimientos o para avisar de restricciones. Esto no es tarea simple y requiere de muchas lineas de código, por lo que un diseño orientado al cambio resulta clave.

Como se discutió previamente, en casos como este se puede aplicar la arquitectura de \textit{Control de procesos}. Este hecho no resuelve todos nuestros problemas de diseño, solo nos brinda una guía y un mecanismo de funcionamiento para el sistema. De todas formas, su uso no es la solución elegida normalmente, es por eso que en la sección se describen ciertas características de las soluciones tradicionales y luego también se trataran que estructuras se pueden usar para llevar a cabo esta arquitectura de una manera simple y probada (por ejemplo, en el robot desmalezador).

\subsection*{Solución tradicional}

Antes de pasar a explicar la solución propuesta y analizar cómo aplicarla al ejemplo presentado por Douglass en su libro \cite{douglass}, se describirá cómo se aborda tradicionalmente esta problemática. Para ello, se tomará como ejemplo el software desarrollado para el robot desmalezador antes de la propuesta del nuevo diseño \cite{paperPomponio}. En particular existieron dos desarrollos creados en conjunto por ingenieros electrónicos como parte del trabajo final de carrera \cite{disenioViejo1, disenioViejo2}. Los requerimientos son similares a los que se consideraron para el desarrollo del nuevo diseño.

\subsubsection*{Estructura y funcionamiento general}

El código se encuentra dividido en unos pocos archivos, concentrando todo el flujo de control en \verb|main.c|, el resto de archivos contienen métodos que son invocados desde este último y son utilidades. No se utiliza programación orientada a objetos, en cambio, como estructura de subdivisión se utilizan las funciones clásicas de C. Estas parece que encapsulan operaciones específicas como:
\begin{itemize}
\item Configuración de hardware.
\item Lectura de entradas (sensores, botones, etc.).
\item Control de salidas (motores, luces, etc.).
\end{itemize}

La información común entre muchas funciones se almacena en variables globales definidas en el mismo archivo. Entre las variables, encontramos algunas que se encargan de almacenar información referida al estado de operacion del sistema. Es decir, que los estados se manejan con sentencias \verb|if| o \verb|switch case| (se comenta sobre esta solución en la sección \nameref{cap:state}).

La función principal del sistema es \verb|main|, la misma se encarga de inicializar y calibrar los sensores y actuadores, de realizar el ciclo de control y terminar la ejecución. Para las primeras dos tareas llama a dos funciones que realizan el trabajo. El ciclo de control se ve representado por un bucle infinito en el cual se realizan las siguientes tareas principales:
\begin{itemize}
\item Lectura de información de los sensores, dirección, velocidad y corriente.
\item En base al estado de ejecución actual, se realizan ciertas tareas.
\item Se aplican cambios a los actuadores, el ciclo de trabajo (\gls{PWM}) de los motores y la dirección.
\end{itemize}

\subsubsection*{Observaciones}
El criterio de división del código parece ser funcional, tanto por el aspecto del código, como por la documentación adjunta en los informes \cite[pág. 78-85]{disenioViejo1}, \cite[pág. 110-149]{disenioViejo2}. Esta ultima, se centra es describir la funcionalidad de cada meteodo y para hacerlo se muestra su comportamiento utilizando diagramas de flujo como el de la figura \ref{diagra}. 

\begin{figure}[h]
\caption{Diagrama de flujo que explica el comportamiento de la función emergency \cite[pág. 82]{disenioViejo1}.}
\label{diagra}
\begin{centering}
{\includegraphics[width=0.8\textwidth]{diagramaFlujo.png}\par}
\end{centering}
\end{figure}


Por otro lado, a lo largo del código se utilizan estructuras condicionales (if, switch, etc.) para determinar el flujo de ejecución. A su vez, las funciones de hardware están directamente integradas en la lógica del control, lo que indica una baja separación entre la capa de abstracción del hardware y la lógica de ``alto'' nivel. Esto es acompañado con un diseño procedimental, con una serie de pasos secuenciales y un control centralizado en el flujo principal. Ademas, el hardware se encuentra integrado a la lógica, se aplican estructuras condicionales directamente a este.

Otros inconvenientes referidos al cambio que están presentes en el código:
\begin{itemize}
\item El código parece estar compuesto por funciones largas y bloques monolíticos sin modularidad clara. Esto dificulta la localización y modificación de funcionalidades específicas, ya que los cambios pueden propagarse a otras partes del sistema.
\item Hay valores ``hardcodeados'' (constantes definidas directamente en el código). Si estos valores cambian, es necesario modificar el código fuente, aumentando el riesgo de introducir errores.
\item Las dependencias entre funciones y módulos están estrechamente acopladas. Lo que provoca que cambiar un módulo pueda requerir modificaciones significativas en otros.
\item El manejo de errores parece ser inconsistente o inexistente en varias secciones. Esto puede llevar a comportamientos impredecibles y dificultar el diagnóstico de problemas.
\end{itemize}

\subsubsection*{Conclusión}

El diseño del código parece estar orientado a cumplir con un objetivo específico mediante un flujo procedimental y un control directo de los periféricos del hardware. Este enfoque es funcional, pero carece de modularidad y abstracción, lo que lo hace menos flexible y más difícil de mantener. La estructura actual no parece diseñada para escalar con nuevas funcionalidades. Lo que tiene sentido, si se tiene en cuenta el contexto del desarrollo.




\subsection{Subsistemas de control}

A fin de aplicar la arquitectura de software de control de proses, se propone la creación de un \textit{subsistema de control} por cada variable a manipular\footnote{Ver tabla conceptos arquitectura Control de Procesos \ref{tab:conceptosArq}} que sea necesaria controlar por el sistema. Como se puede intuir, un subsistema de control se encarga del control de una propiedad en particular y para hacerlo lleva a cabo todas las tareas de la arquitectura a su nivel. Por lo tanto, debe proveer una interfaz que permita setear un valor al que se quiera llevar la propiedad (\textit{setPoint} (ver  \ref{tab:conceptosArq})) y que indique el comienzo de la tarea de control. Un subsistema tiene una estructura similar a la de la arquitectura \ref{fig:arqCtrlRobot}, pero su alcance estará restringido a la variable a manipular y las variables medidas relacionadas.


En la imagen \ref{modulosSub} se puede observar de manera concreta qué módulos forman parte de cada componente de un subsistema.


\begin{figure}[h!]
\caption{Módulos de un subsistema}
\label{modulosSub}
\begin{center}
\begin{tikzpicture}\sf

\umlclass[]{Control}
{}
{setPoint(i: Measure)\\
control() \\
connectionRead() \\
setAlgoritmo(i: Algoritmo) \\
setConnection(i: Pipe)
}

\umlclass[below=6cm of Control]{Sensor}
{}
{setConnection(i: Pipe) \\
signal()
}
\umlnote[below left=-1cm and 1cm of Sensor,width=4cm]{Sensor}{
signal()\{ \\
\ \ \ \ value = getValue()\\
\ \ \ \ pipe.write(value)\\
\}
}

\umlclass[below=3cm of Control]{Actuador}
{}
{actuar()
}
\umlclass[left=2cm of Actuador]{Pipe}
{}
{read(): Measure \\
write(i: Measure)
}


\umlnote[below right=0.5cm and 2cm of Actuador]{Actuador}{
Por lo general se desacopla usando el patrón \textit{command} y su uso puede ser más complejo que solo ejecutar una función.
}



\umlclass[above right=-1cm and 2cm of Control]{Algoritmo}
{}
{calcular(): Measure
}
\umlclass[below right=-1.5cm and 2cm of Control]{Data}
{}
{setSetPoint(i: Measure) \\
getSetPoint(): Measure \\
setCurrent(i: Measure) \\
getCurrent(): Measure
}

\umluniaggreg[anchor1=10,anchor2=west]{Control}{Algoritmo}
\umluniaggreg[anchor1=-10,anchor2=west]{Control}{Data}

\end{tikzpicture}
\end{center}
\end{figure}

La manera en la que un \textit{cliente} utiliza el subsistema para lograr que la propiedad que controla vaya al valor que se desea es de la forma indicada en el código \ref{usoSubsistema}.

\begin{lstlisting}[caption=Ejemplo de uso del subsistema.,label={usoSubsistema},style=seudocode]
control.setPoint(valorDeseado)
sensor.signal()
control.connectionRead()
control.control()
\end{lstlisting}

Notar que aparecen algunos módulos que no fueron mencionados anteriormente, por un lado \textbf{Algoritmo} el cual se encarga de el calculo necesario para determinar de que manera llamar aplicar un cambio con el/los actuadores. Por ejemplo, determina si se llego o no al \textit{set-point}. Y podría definir que cambio es necesario aplicar para llegar al mismo. En el ámbito de la robótica se aplican diferentes técnicas de estabilización\footnote{La estabilización es crucial para evitar oscilaciones, reducir el tiempo de respuesta y minimizar sobrepasos, garantizando un control preciso y eficiente. Un sistema bien ajustado responde de manera estable ante perturbaciones externas y optimiza el consumo energético, mejorando la fiabilidad y el desempeño en aplicaciones como robótica y automatización.} variables físicas, las cuales permiten alcanzar un cierto \textit{set-point} y mantenerse en el, por ejemplo, los controladores \gls{PID}\cite{pidlibro} (controlador proporcional, integral y derivativo). Los cuales representan un mecanismo de control que a través de un lazo de retroalimentación permiten manejar una variable física. Este tipo de técnicas puede ser usada siguiendo la arquitectura propuesta y, en particular, los cálculos asociados se definirían en este módulo \textbf{Algoritmo}.

Por otro lado, tenemos \textbf{Data} que desacopla el almacenamiento de información relacionada al subsistema. En el caso mas básico solo tenemos el \textit{set-point}, pero puede agregarse todo lo necesario, incluso llevar registro de los valores actuales y pasados.

Ahora, para brindar un comportamiento más complejo, es posible que el control necesite realizar múltiples ciclos para ajustar la variable al valor deseador, como pasa cuando trabajamos con motores paso a paso (luego veremos un ejemplo). ¿Cómo podemos hacer esto usando nuestra estructura? Necesitamos dos modificaciones/adiciones, por un lado, una interrupción de control que llame a cierto método del módulo \textbf{Control} cada determinado tiempo (tiempo del ciclo), generalmente resuelto con una interrupción \textit{temporizada} y por el otro, necesitamos crear la noción de estado a nuestro módulo de control. Tendremos dos estados básico, en espera, cuando no se esta realizando un ciclo de control y trabajando, cuando se haya establecido un \textit{set-point} y se este trabajando para llegar. Para hacerlo utilizamos un nuevo método y el patrón \textit{state}\footnote{El uso de este patrón está explicada en la sección \nameref{cap:state}.} y se obtiene el esquema \ref{controlState} (en \ref{docStateControl} se encuentra la documentación de la aplicación del patrón).

\begin{figure}[h]
\caption{Estructura módulo \textbf{Control} extendida con estado.}
\label{controlState}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=-4]{Control}
{}
{setPoint()\\
control() \\
cicle() \\
leer() \\
setAlgoritmo(i: Algoritmo) \\
changeState(i: State)
}
\umlnote[x=-5, y=5, width=4cm]{Control}{
Delega al estado interno tanto control() como cicle()
}

\umlclass[x=4, y=3,type=abstract]{State}
{}
{
\umlvirt{control()} \\
\umlvirt{cicle()} \\
}

\umlclass[x=2,y=-2]{Waiting}
{}
{
control() \\
cicle() \\
}


\umlclass[x=6,y=-2]{Working}
{}
{
control() \\
cicle() \\
}

\umlinherit[geometry=|-|]{Waiting}{State}
\umlinherit[geometry=|-|]{Working}{State}
\umluniaggreg[geometry=-|-]{Control}{State}

\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}
\caption{Documentacion de la aplicación del patrón State en el módulo Control.}
\label{docStateControl}
\begin{pattern}[]{Estados de operación del controlador}{Algorithm}{idFigAlg}
\based{Estado (State)}
\why{\textbf{Cambios previstos}: El controlador lleva a cabo el control dependiendo del estado en el que se encuentre. Podrían cambiar el comportamiento requerido de algunos de los estados definidos o bien podría ser necesario agregar nuevos estados con sus correspondientes comportamientos.

\textbf{Funcionalidad}: Dependiendo del estado, los métodos control y cicle deben comportarse de manera diferente. A su vez, pueden cambiar de manera dinámica. En caso de que no se esté realizando una accion sobre alguno de los actuadores que 
}
\assigns
\is{Control}{Contexto}
\is{State}{Estado}
\is{Waiting}{EstadoConcreto}
\is{Working}{EstadoConcreto}
\end{pattern}
\end{figure}


El cliente ejecuta \verb|control()| y la interrupción que marca el ciclo de trabajo ejecuta \verb|cicle()|. De esta manera, cuando el estado es \textit{waiting}, \verb|cicle()| no hace nada y cuando está en \textit{working} \verb|control()| no hace nada y la otra función se encarga de realizar el ciclo de control.
Por supuesto, estas dos funciones son las encargadas de llamar a \verb|changeState()| cuando sea necesario. \verb|control()| cambia a \textit{working} y cuando se alcanza el \textit{set-point}, \verb|cicle()| cambia el estado a \textit{waiting}.

En el diseño del robot desmalezador\cite{paperPomponio} existe un \textit{timer} que desencadena una interrupción cada 1.5\textit{ms} la cual ejecuta el ciclo de control del subsistema de dirección del robot. Este consta de un motor paso a paso, por lo que cada ciclo verifica la diferencia de posición actual con la deseada y si aun no se llego al mínimo de diferencia deseado se envía un pulso al motor para que avance.

Antes de ver un ejemplo repasemos que conseguimos al usar los subsistemas de control. Principalmente encapsulamos el control de cada propiedad de manera independiente, permitiendo que cada una pueda modificarse de manera aislada. Además, se logra que agregar nuevas propiedades con su conjunto de actuadores y sensores conste únicamente en crear nuevos módulos. Se provee una capa de abstracción para construir sobre los sistemas un controlado general (ej. MainController) el cual organizará los esfuerzos de cada uno con el fin de llevar a cabo comportamientos más complejos. Luego veremos como incluso podemos aplicar para esto el patrón \textit{mediator}.

\subsection{Ejemplo}

Veamos como podemos resolver el ejemplo propuesto en el libro de Douglass\cite{douglass} en la sección de 3.4 Mediator Pattern.

\subsubsection*{Requisitos}

Se necesita desarrollar el software de control de un brazo robótico que consta de tres actuadores, dos servomotores (uno para rotar y otro para extender o retraer el brazo) y una pinza que se puede cerrar o abrir. Para ello, se provee una función compleja la cual toma coordenadas en el espacio y genera una secuencia de ordenes para que el brazo tome un objeto en la posición determinada por las coordenadas. La secuencia es una serie de pasos, y cada uno consta de una orden para cada actuador del brazo robótico. Estos se deben ejecutar de manera secuencial, es decir que el paso número 2 empezará su ejecución solo si el primero culmino completamente y con éxito. En caso de que las coordenadas sean inalcanzables devuelve 0 pasos. A su vez cada actuador puede informar un error al intentar ejecutar cada movimiento, y si esto pasa se requiere frenar la ejecución total del sistema.

\begin{figure}[h]
\caption{Esquema del brazo robótico.}
\begin{centering}
{\includegraphics[width=0.5\textwidth]{brazo2.png}\par}
\end{centering}
\end{figure}

\subsubsection*{Solución propuesta en el libro de Douglass}

El ejemplo que plantea el libro es similar al descrito, pero el brazo robótico tiene más articulaciones y actuadores. Como solución, se propone la creación de un módulo llamado \textbf{RobotArmManager}, cuya función es gestionar los actuadores y coordinar su comportamiento. Además, para cada tipo de articulación o actuador, se crea un módulo específico encargado de su control. Este módulo proporciona métodos para consultar el estado actual (posición, longitud, etc.) y otros para configurar un valor similar a un \textit{set-point}. Dichos métodos desempeñan el rol de ejecutores de la acción, es decir, toman un valor \textit{set-point}, ejecutan la acción y retornan \verb|True| si fue satisfactoria, o \verb|False| en caso contrario.

El comportamiento del sistema comienza con la generación de una lista de pasos a realizar. Luego, se itera sobre esta lista ejecutando las acciones definidas en cada paso. Como el sistema debe interrumpir la ejecución si encuentra un error, el \textbf{RobotArmManager} verifica el valor de retorno tras cada acción. La ejecución de un movimiento completo finaliza cuando se completan todos los pasos generados previamente por el método \verb|graspAt(i: Coordenadas)|.

La solución propuesta parece estar un nivel por encima de lo que se esperaría para este caso. Aunque no hay suficiente información sobre el hardware del brazo robótico, generalmente mover una articulación no es tan simple como invocar un método. Este proceso suele requerir el control continuo de un motor paso a paso, que opera mediante pulsos que avanzan un paso. Por lo tanto, los módulos encargados de los movimientos probablemente tengan más responsabilidades de las que se plantean en el libro. Además, sería necesario implementar un sistema de control más complejo, utilizando algún tipo de \textit{timer} o espera, para garantizar que el motor paso a paso tenga el tiempo necesario para actuar.

De todas formas, suponiendo que los módulos mencionados se adaptan al hardware subyacente, la manera en la que el \textbf{RobotArmManager} interactúa con ellos resulta rígida, tanto por la invocación directa como por la dependencia del valor de retorno. Esto se evidencia en el código resultante, que incluye múltiples sentencias \textit{if} consecutivas.

Por otro lado, un ítem de cambio común son las estructuras de datos, como se mencionó en \ref{listaItems}. Por ello, establecer el uso de una lista directamente en el diseño no responde a una buena práctica.

Es posible que el problema haya sido simplificado con fines didácticos. Sin embargo, la forma planteada parece alejarse de una implementación realista, dejando requisitos menos específicos que podrían dar lugar a diferentes interpretaciones.

Por le lado de la aplicacion del patron \textit{Mediator}, Gamma establece que es aplicable en los siguientes casos:
\begin{itemize}
\item Un conjunto de módulos se comunica de maneras bien definidas pero complejas. Las interdependencias resultantes son desestructuradas y difíciles de comprender.

\item Reutilizar un módulo resulta complicado porque este se refiere y se comunica con muchos otros módulos.

\item Un comportamiento distribuido entre varios módulos debería ser personalizable sin requerir una gran cantidad de subclases.
\end{itemize}

Entiendo que la estructura lograda sea similar al patrón, pero originalmente los módulos encargados de ejecutar tareas relacionadas con un actuador específico no necesitaban comunicarse entre sí. Según el propósito del patrón, Gamma establece que el objetivo principal es reducir el acoplamiento, evitando que los módulos se refieran directamente entre ellos. Y este objetivo parece estar logrado en el diseño propuesto.

\subsubsection*{Solución orientada al cambio}

La idea es utilizar el concepto de subsistemas que se introdujo previamente, para ello primero necesitamos identificar las propiedades del mundo físico que debemos controlar. Claramente, lo que se quiere modificar es la posición y el estado de la pinza del brazo, para hacerlo tenemos distintos actuadores que intervienen en diferentes propiedades atómicas. Además, en los requisitos nos especifican que poseemos una función que nos genera una orden para cada actuador. De esta manera definimos un subsistema de control por cada actuador que serán los encargados de llevar a cabo las ordenes generadas. Un ejemplo de orden es rotar 30\textdegree, es claro el \textit{set-point} que se está indicando. Para coordinar los subsistemas proponemos un controlador principal llamado \textbf{MainController}, el cual provee el método \verb|graspAt(i: Coordenadas)| al cliente, realiza la generación de los pasos y controla su ejecución. La estructura seria algo así:


\begin{figure}[h]
\caption{Diagrama de los componentes del sistema brazo robótico.}
\begin{center}
\includegraphics[scale=0.6]{componentes.png}
\end{center}
\end{figure}







Podemos pensar que el gráfico tiene cierta similaridad conceptual con el patrón \textit{mediator}, donde tenemos un módulo \textbf{Mediator} que coordina el trabajo de los \textbf{College} en este caso los subsistemas. Gamma indica que el patrón suele ser apropiado para casos en lo que se tiene un conjunto de objetos que se comunican de manera compleja pero fija. En este caso la comunicación no es tan compleja, pero puede considerarse lo suficiente como para implementar el patrón. En particular, el \textbf{MainController} indica los \textit{set-point} de cada subsistema y desencadena el proceso de control en cada uno. Y viceversa, los subsistemas indican cuando llegan al \textit{set-point} o cuando se encuentran un error. A su vez, los subsistemas no se comunican de manera directa entre si, todo pasa por el \textbf{MainController}.

Veamos en detalle los módulos conforman cada componente comenzando por los módulos básicos que debemos crear para representar el hardware dado (ver gráfico \ref{estructuraActuadores}):

\begin{figure}[h]
\caption{Actuadores paso a paso.}
\label{estructuraActuadores}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{StepDevice}
{}
{
\umlvirt{right()} \\
\umlvirt{left()} \\
\umlvirt{disable()}\\
\umlvirt{enable()} \\
\umlvirt{pulse()}
}

\umlclass[below left=1cm and -0.3cm of StepDevice]{Rotor}
{}
{
right() \\
left() \\
disable() \\
enable() \\
pulse()
}

\umlclass[below right=1cm and -0.3cm of StepDevice]{Extensor}
{}
{
right() \\
left() \\
disable()\\
enable() \\
pulse()
}

\umlinherit[geometry=|-|]{Rotor}{StepDevice}
\umlinherit[geometry=|-|]{Extensor}{StepDevice}

\end{tikzpicture}
\end{center}
\end{figure}

Estos son motores paso a paso\footnote{Se utiliza el mismo diseño propuesto para el robot desmalezador\cite{paperPomponio}.}, lo cuales para controlarlos debemos primero setear su dirección llamando a las funciones \verb|right| o \verb|left| para luego avanzar un paso llamando al método \verb|pulse|. Claramente para que lleguen a la posición deseada puede ser necesario invocar reiteradas veces al método \verb|pulse|. Esto será importante a la hora de diseñar el subsistema que controlará cada dispositivo.

En cambio, en el caso de la pinza se utiliza un dispositivo que tiene dos estados, abierto o cerrado, por lo que solo tenemos dos funciones para cambiar entre los estados.

\begin{figure}[h]
\caption{Interfaz módulo Pinza.}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Pinza}
{}
{
abrir() \\
cerrar()
}

\end{tikzpicture}
\end{center}
\end{figure}

Vemos ahora los sensores asociados a cada actuador, estos heredaran del módulo sensor pasivo el cual provee dos funciones, \verb|setConnection(i: Pipe)| la cual configura el \textbf{Pipe} por el cual se enviará la información obtenida del sensor cuando la otra funciones, \verb|signal()| sea invocada.

\begin{figure}[h]
\caption{Sensores}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{PasiveSensor}
{}
{
\umlvirt{setConnection(i: Pipe)} \\
\umlvirt{signal()} \\
}

\umlclass[x=-5,y=-4]{SensorEstadoPinza}
{}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlclass[x=0,y=-4]{SensorPosRotor}
{}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlclass[x=5,y=-4]{SensorPosExtensor}
{}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlinherit[geometry=|-|]{SensorEstadoPinza}{PasiveSensor}
\umlinherit[geometry=--]{SensorPosRotor}{PasiveSensor}
\umlinherit[geometry=|-|]{SensorPosExtensor}{PasiveSensor}


\end{tikzpicture}
\end{center}
\end{figure}

Para completar los módulos que conforman a un subsistema de control nos falta mostrar como se define el \textbf{Controller}. Vamos a diferenciar dos tipos de \textbf{Controllers}, uno para los sensores que requieren un control durante un determinado lapso de tiempo para poder llegar a su \textit{set-point} y los que no. En este ejemplo, tenemos dos motores paso a paso que representan el primer tipo y la pinza que corresponde al segundo. Vemos primero el caso más ``complejo'', como el proceso de control se extiende en el tiempo necesitamos añadir al sistema un mecanismo por el cual cada cierto intervalo ejecute un ciclo de control, es decir, lea la posición actual, decida y actúe. Para eso, en el diseño del robot desmalezador se propuso la creación de una interrupción temporizada, la cual se ejecuta cada 1.5\textit{ms} y desencadena el control de los subestimas necesarios.


\begin{figure}[h]
\caption{Timer}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Timer}
{}
{
setPeriod(i: Real) \\
start() \\
stop() \\
tickHandler()
}

\umlnote[above right=-2cm and 1cm of Timer,width=7cm]{Timer}{
tickHandler() \{ \\
subsistemControlTimeout.execute() \\
\}
}

\umlsimpleclass[below right=0cm and 2cm of Timer]{Command}
\umluniassoc[geometry=|-]{Timer}{Command}
\end{tikzpicture}
\end{center}
\end{figure}

El método \verb|tickHandler()| ejecutará comandos siguiendo patrón \textit{Command} por cada subsistema que lo necesite, por lo tanto se iniciará en cada uno el ciclo de control. En particular, la orden es utilizada para desacoplar como es invocado el inicio del \textbf{Timer}. En la figura \ref{docCommandTimer} se puede observar la documentación de la aplicación del patrón \textit{Command} para este caso.

\begin{figure}
\caption{Documentacion de la aplicación del patrón Command para el desacople de ejecuciones que invoca el Timer.}
\label{docCommandTimer}
\begin{pattern}[]{Comando para manejar interrupciones generadas por el Timer.
Sustitución de callback}{Algorithm}{idFigAlg}
\based{Orden (Command)}
\why{\textbf{Cambios previstos}: Las acciones a llevar a cabo ante una interrupcion provocada por el Timer podrían cambiar; o incluso podría cambiar el receptor de dichas acciones, que actualmente es Controller.

\textbf{Funcionalidad}: Se mantienen los niveles de abstracción. El módulo Timer, desconoce la existencia de módulos de niveles superiores como el Controller.
}
\assigns
\is{Command}{OrdenConcreta}
\is{Timer}{Invocador}
\is{Controller}{Receptor}
\end{pattern}
\end{figure}


Una vez solucionada la invocación, tenemos que introducir un nuevo módulo que será usado en el \textbf{Controller}. Ahora, tenemos dos modos de operación de este ultimo, cuando no se está trabajando y cuando si. Dependiendo de cual de los dos esté activo el comportamiento será diferente, ya que por ejemplo, no apagamos el \textbf{Timer} cuando no se está haciendo un movimiento, sino que cuando este desencadene la ejecución del ciclo el \textbf{Controller} ignorará la orden. Para esto hacemos uso del patrón \textit{State} de Gamma\cite{Gamma:1995:DPE:186897}, el cual está explicado en la sección \ref{cap:state}. En particular, el \textbf{Controller} delegará dos funciones de su interfaz al \textit{state}, \verb|control()| y \verb|move()| (luego lo veremos en más detalle).

\begin{figure}[h]
\caption{Módulos necesarios para complementar el Controller}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{OperationState}
{}
{
\umlvirt{control(i: Controller)} \\
\umlvirt{move(i: Controller)} \\
}

\umlclass[x=-3,y=-4]{Moving}
{}
{
control(i: Controller) \\
move(i: Controller) \\
}

\umlclass[x=3,y=-4]{Waiting}
{}
{
control(i: Controller) \\
move(i: Controller) \\
}

\umlinherit[geometry=|-|]{Moving}{OperationState}
\umlinherit[geometry=|-|]{Waiting}{OperationState}

\end{tikzpicture}
\end{center}
\end{figure}

Siguiendo con la guía de creación de subsistemas, también debemos definir el módulo \textbf{Data} que almacena la información utilizada por el mismo y el módulo \textbf{Algoritmo} que encapsula los cálculos necesarios para determinar que cambio aplicar.

\begin{figure}[h]
\caption{Módulos complementarios a Controller.}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[x=-3]{Data}
{}
{
setSetPoint(i: Measure) \\
getSetPoint(): Measure \\
setCurrent(i: Measure) \\
getCurrent(): Measure
}

\umlclass[x=3]{Algoritmo}
{}
{
compute(i: Data): Measure
}

\end{tikzpicture}
\end{center}
\end{figure}

Ahora si tenemos todos los módulos necesarios para mostrar nuestro \textbf{Controller}.

\begin{figure}[h]
\caption{Controller}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Controller}
{}
{
setConnection(i: Pipe) \\
readConnection() \\
setSetPoint(i: Measure) \\
getData(): Data \\
getAlgoritmo(): Algoritmo \\
changeOperationState(i: OperationState) \\
move() \\
control()
}

\umlsimpleclass[above right=-1.5cm and 1cm of Controller]{Data}
\umlsimpleclass[above right=-2.5cm and 1cm of Controller]{Algoritmo}
\umlsimpleclass[above right=-3.5cm and 1cm of Controller]{OperationState}
\umlsimpleclass[above right=-4.5cm and 1cm of Controller]{Pipe}

\umluniaggreg[anchor1=22,anchor2=west]{Controller}{Data}
\umluniaggreg[anchor1=7,anchor2=west]{Controller}{Algoritmo}
\umluniaggreg[anchor1=-7,anchor2=west]{Controller}{OperationState}
\umluniaggreg[anchor1=-22,anchor2=west]{Controller}{Pipe}

\end{tikzpicture}
\end{center}
\end{figure}

Veamos la funcionalidad de cada método que provee la interfaz de Controller:
\begin{itemize}
    \item setConnection: configura el tubo por el cual llegará la información proveniente de el/los sensores.
    \item readConnection: lee del pipe y almacenar la información en el módulo data.
    \item setSetPoint: se utiliza antes de comenzar el control para configurar el valor al que se quiere llegar.
    \item getData: devuelve el objeto Data asociado al \textbf{Controller}.
    \item getAlgoritmo: lo mismo que con Data.
    \item changeOperationState: cambia el estado del modo de operación, en la configuración básica las transiciones posibles son de \textit{Waiting} a \textit{Moving} y viceversa.
    \item move: es el método ejecutado en cada timeout del \textbf{Timer} de control, realiza un paso del ciclo de control si el estado es \textit{Moving}.
    \item control: se utiliza para comenzar el ciclo de control, es el puntapié inicial que desencadena el comportamiento de todo el subsistema.
\end{itemize}

Imaginemos que un cliente quiere utilizar el subsistema, qué métodos tiene que ejecutar si ya está configurado? Primero debe indicarle a los sensores que escriban el valor de lectura en el pipe, para esto hay que ejecutar el método \verb|signal| en cada uno. Luego el \textbf{Controller} debe leer esta información del pipe y almacenarla, para esto ejecutamos \verb|readConnection|. Ahora, seteamos el setPoint deseado y por ultimo ejecutamos \verb|control|, la cual tomará los valores actuales, el \textit{set-point} y decidirá utilizando el módulo \textbf{Algoritmo} que cambio realizar en los actuadores. En el caso del \textbf{Rotor}, por ejemplo, podrá tanto cambiar la dirección de giro, como avanzar un paso ejecutando \verb|pulse()|. Un ejemplo del metodo \verb|control()| para el caso del subsistema del \textbf{Rotor} y estado de operación \textit{Waiting}, puede ser la del código \ref{impControl} (recordar que el \textit{set-point} del subsistema del rotor es una medida en grados).

\begin{lstlisting}[caption=Ejemplo implementación control,label={impControl}]
    void control(Controller controller) {
        setPoint = data.getSetPoint();
        current = data.getCurrent();
        dif = controller.algoritmo.calculate()
        if abs(dif) > LIMIT_ACCEPT && dif > 0 {
            rotor.left();
            rotor.pulse;
            controller.changeOperationState(moving);
            return;
        }
        if abs(dif) > LIMIT_ACCEPT && dif < 0 {
            rotor.right();
            rotor.pulse;
            controller.changeOperationState(moving);
            return;
        }
    }
\end{lstlisting}

El método \verb|move| tendrá un comportamiento similar pero en el aso de cambiar de estado lo hará a \textit{Waiting}. Para el caso de la \textbf{Pinza}, el \textbf{Controller} es más simple ya que no necesitamos los estados, pero el uso y comportamiento es similar. Por lo que para este ejemplo, vamos a necesitar crear dos subsistemas con estados y uno sin.

Ya tenemos los subsistemas, por lo que siguiendo con nuestro diagrama, nos falta la parte del \textbf{MainController}. El cual sera el encargado de brindar una interfaz al cliente y a su vez coordinar cada subsistema. Recordando los requerimientos, sabemos que tenemos una función que generar una secuencia de pasos donde cada uno implica una acción sobre los tres actuadores. ¿Cómo se puede diseñar este comportamiento? Una opción es usar un \textit{iterator} para recorrer los pasos y aplicar el patrón \textit{command} para cada uno. En particular, se aplica una de las modificaciones del patrón mencionada por Gamma\cite{Gamma:1995:DPE:186897}, en donde una orden al ser ejecutada desencadena una ejecución del resto de las ordenes. Esto se puede ver en los gráficos \ref{iterator}, \ref{orden} y \ref{docCommandSteps}.

\begin{figure}[h]
\caption{Iterator}
\label{iterator}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Steps}
{}
{
primero() \\
siguiente()\\
elementoActual(): Orden\\
haTerminado(): Bool\\
}


\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}[h]
\caption{Orden}
\label{orden}
\begin{center}
\scalebox{.75}{
\begin{tikzpicture}\sf

\umlclass[type=abstract]{Orden}
{}
{
\umlvirt{ejecutar()}
}

\umlclass[below left=2cm and 4.5cm of Orden]{OrdenRotor}
{
OrdenRotor(i: Measure)
}
{
ejecutar()
}

\umlclass[below left=2cm and -1cm of Orden]{OrdenExtensor}
{
OrdenExtensor(i: Measure)
}
{
ejecutar()
}

\umlclass[below right=2cm and -1cm of Orden]{OrdenPinza}
{
OrdenPinza(i: Measure)
}
{
ejecutar()
}

\umlclass[below right=2cm and 4cm of Orden]{OrdenMultiple}
{
OrdenMultiple(i: OrdenRotor, \\ i: OrdenExtensor, \\i: OrdenPinza)

}
{
ejecutar()
}
\umlinherit[geometry=|-|]{OrdenRotor}{Orden}
\umlinherit[geometry=|-|]{OrdenExtensor}{Orden}
\umlinherit[geometry=|-|]{OrdenPinza}{Orden}
\umlinherit[geometry=|-|,arm1=2.54cm]{OrdenMultiple}{Orden}
\umluniaggreg[geometry=-|-, anchor1=east, arm1=1cm]{OrdenMultiple}{Orden}
\umlnote[above=4cm of OrdenMultiple,width=5cm]{OrdenMultiple}{
ejecutar() \{  \\
\ \ \ \ ordenRotor.ejecutar() \\
\ \ \ \ ordenExtensor.ejecutar() \\
\ \ \ \ ordenPinza.ejecutar() \\
\}
}

\end{tikzpicture}}
\end{center}
\end{figure}

\begin{figure}
\begin{lstlisting}[caption=Ejemplo OrdenRotor]
void ejecutar {
    rotorController.setSetPoint(setPoint)
    rotorSensor.signal()
    rotorController.readConnection()
    rotorController.control()
}
\end{lstlisting}
\end{figure}


\begin{figure}[h]
\caption{Documentación de la aplicación del patrón Command para el desacople de ordenes a ejecutar en cada actuador del brazo en un paso.}
\label{docCommandSteps}
\begin{pattern}[]{Comando para manejar las acciones que deben ser ejecutadas en un paso en cada actuador.}{Algorithm}{idFigAlg}
\based{Orden (Command)}
\why{\textbf{Cambios previstos}: Las acciones a llevar a cabo para cada actuador pueden cambiar, se pueden agregar o quitar actuadores.

\textbf{Funcionalidad}: Se logra ejecutar una acción sobre todos los actuadores configurados con una sola acción del invocador.
}
\assigns
\is{Orden}{Orden}
\is{OrdenRotor}{OrdenConcreta}
\is{OrdenExtensor}{OrdenConcreta}
\is{OrdenPinza}{OrdenConcreta}
\is{OrdenMultiple}{OrdenConcreta}
\is{MainController}{Invocador}
\is{RotorController}{Receptor}
\is{ExtensorController}{Receptor}
\is{PinzaController}{Receptor}

\end{pattern}
\end{figure}


Se tiene un iterado de ordenes, en particular múltiples, que almacena todos los pasos de ejecución que la función provista generará. Por lo que el \textit{MainController} podrá recorrerlos ejecutando cada orden de manera sencilla. Logramos, almacenar el procedimiento a realizar y desacoplar como se pone en marcha el ciclo de control en cada subsistema.

\begin{figure}[h]
\caption{MainController}
\begin{center}
\scalebox{.75}{
\begin{tikzpicture}\sf
\umlclass[x=-5,y=0]{MainController}
{
MainContoller(i: StepsComputator)
}
{
graspAt(i: Coordenadas) \\
notifyReady() \\
notifyError() \\
changeState()
}
\umlclass[x=0,y=-4,type=abstract]{MainControllerState}
{}
{
\umlvirt{graspAt(i: Coordenadas)} \\
\umlvirt{notifyReady(i: MainCtrl)} \\
}
\umlclass[x=-10,y=-8]{MainWaiting}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}
\umlclass[x=-5,y=-8]{Main0}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}
\umlclass[x=0,y=-8]{Main1}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}
\umlclass[x=5,y=-8]{Main2}
{}
{
graspAt(i: Coordenadas) \\
notifyReady(i: MainCtrl) \\
}



\umlclass[x=3,y=0]{StepsComputator}
{
}
{
geneararStepts(i: Coordenadas) \\
}
\umluniaggreg{MainController}{StepsComputator}
\umluniaggreg[geometry=|-]{MainController}{MainControllerState}
\umlinherit[geometry=|-|]{MainWaiting}{MainControllerState}
\umlinherit[geometry=|-|]{Main0}{MainControllerState}
\umlinherit[geometry=|-|]{Main1}{MainControllerState}
\umlinherit[geometry=|-|]{Main2}{MainControllerState}
\umlnote[x=-9,y=-4,width=6.5cm]{MainController}
{
void notifyReady() \{ \\
\ \ \ \ mainControllerState.notifyReady() \\
\}
}


\end{tikzpicture}
}
\end{center}


\end{figure}

\begin{pattern}[]{Estados de operación del controlador principal}{Algorithm}{idFigAlg}
\based{Estado (State)}
\why{\textbf{Cambios previstos}: El controlador principal llevará a cabo el control de los subsistemas de control, dependiendo del estado en el que se encuentre. Podrían cambiar el comportamiento requerido de algunos de los estados definidos o bien podría ser necesario agregar nuevos estados con sus correspondientes comportamientos.

\textbf{Funcionalidad}: Teniendo en cuenta que para poder ejecutar un nuevo paso se deben haber finalizado con éxito todas las operaciones sobre actuadores, se introducen estados por cada orden terminada, a fin de que solo al hacer una transición completa se puede ejecutar un nuevo paso.
}
\assigns
\is{MainController}{Contexto}
\is{MainControllerState}{Estado}
\is{MainWaiting}{EstadoConcreta}
\is{Main1}{EstadoConcreta}
\is{Main2}{EstadoConcreta}
\is{Main3}{EstadoConcreta}

\end{pattern}

Hasta la introducción de \textbf{MainController} todo lo que estábamos haciendo era solo seguir con el concepto de subsistemas. Pero para poder cumplir los requerimientos particulares del ejemplo, necesitamos introducir ciertos cambios. Como necesitamos ejecutar un paso a la vez, tenemos que esperar que todas las ordenes que enviamos en el paso anterior a los subsistemas. Para ello hacemos uso del patrón \textit{state}, al cual delegaremos las funciones \verb|graspAt| y \verb|notifyReady|. La idea es cambiar el comportamiento de estas dependiendo de en qué estadio estamos, seguiremos el siguiente gráfico \ref{statesMainController}.

\begin{figure}[h!]
\caption{Transiciones de estados del MainController}
\label{statesMainController}
\begin{center}
\begin{tikzpicture}

\umlsimpleclass[fill=red!20,x=-2]{Waiting}
\umlsimpleclass[fill=red!20,x=2]{0}
\umlsimpleclass[fill=red!20,x=2, y=-2]{1}
\umlsimpleclass[fill=red!20,x=2, y=-4]{2}

\umltrans[arg=graspAt,pos=0.5]{Waiting}{0}
\umltrans[arg=notifyEnd,pos=0.5]{0}{1}
\umltrans[arg=notifyEnd,pos=0.5]{1}{2}
\umltrans[arg=notifyEnd,pos=1.5,arm1=3cm,geometry=-|-]{2}{0}

\end{tikzpicture}
\end{center}
\end{figure}

Por lo que, el estado Waiting no implementa \verb|notifyOrder| y a su vez 0, 1 y 2 no implementan \verb|graspAt|. En cambio, Waitating implementan \verb|graspAt| la cual computa los pasos y ejecuta el primero utilizando el iterator. Luego, por cada \verb|notifyEnd| los subsistemas le avisan al MainController que terminaron la orden y por cada una transaccionamos a un estado nuevo. Luego de que se ejecuta \verb|graspAt| se transiciona al estado 0 en el cual al recibir un \verb|notifyEnd| se transiciona a 1 y lo mismo hasta llegar a 2. En cambio, cuando estamos en el estado 2 y se ejecuta \verb|notifyEnd| lo que se hará es ejecutar un nuevo paso si en el iterador de pasos quedan pasos, en caso contrario se transicionará a Waiting ya que se terminó la ejecución. Está claro que para poder llevar a cabo este comportamiento es necesario que los subsistemas respondan a las necesidades. Por lo que cada uno tendrá que llamar al método \verb|notifyEnd| del \textbf{MainController} cuando efectivamente terminen la ejecución de la orden, es decir, el ciclo de control. Para hacerlo se puede agregar la llamada en la cuando se decide transicionar de \textit{Moving} a \textit{Waiting }o en el caso de los subsistemas sin estados, luego de aplicar los cambios en los actuadores.

\newpage
\section{Obtención de información}
\label{obtInfo}

Generalmente una tarea importante que tienen los sistemas embebidos es recavar información proveniente de sensores. Existen diferentes formas en las que los sensores transmiten información al sistema, algunos, por ejemplo un sensor de temperatura, setea en el pin en el que esta conectado un cierto valor de tensión, por lo que el sistema solo debe consultar el valor del pin. Otros, en cambio, se comunican mediante interrupciones, por ejemplo un sensor de efecto \textbf{Hall} genera una interrupción por cada detección de campo magnético. Por lo tanto, si lo estamos usando para calcular las \textbf{RPM} de cierto componente giratorio, debemos llevar una cuenta de las interrupciones que generó en cierto periodo de tiempo y realizar cierta matemática. Evidentemente, es necesario que alguna porción de nuestro sistema se encargue de hacerlo y maneje las interrupciones generadas por el sensor. Algo similar pasa con otro tipos de sensores como joysticks, botones, etc.

Tradicionalmente esta tarea es centralizada en un único módulo, generalmente representado por un método, que se encarga de manejar la interrupción y almacenar el estado resultante. De esa manera se obtiene una estructura resiliente al cambio, en la cual se dificulta reutilizar código y las funcionalidades están altamente acopladas. Esto es, por ejemplo, si se modifican los cálculos para obtener el resultado deseado, se debe modificar a su vez la toda la implementación. Así como en caso de que cambie la manera en que se maneja la interrupción.

Es por esto que resulta útil una forma general de atacar este problema desde el punto de vista del diseño para el cambio, en el trabajo que se realizó sobre el robot desmalezador \cite{paperPomponio}, se utilizó una estructura de módulos que lleva a cabo las actividades necesarias para integrar al sistema los sensores que generan interrupciones. La estructura del mismo se puede observar en la figura \ref{activo}.

\begin{figure}[h!]
\caption{Estructura componentes para la lectura de un sensor activo.}
\label{activo}
\centering
\begin{tikzpicture}\hypertarget{fig:ConnectBufferToMCU}{}
%-------------Estilos para dibujar-----
\tikzstyle{módulo}=[minimum width=1cm,inner sep=2mm,above right,draw,align=center,minimum width=2cm, font=\bfseries]

\tikzstyle{supest}=[rounded corners=1.5mm, minimum width=2cm,inner sep=2mm,draw,text width=2cm]

\tikzstyle{componente}=[minimum width=2cm,inner sep=2mm,draw,text width=2cm]

\tikzstyle{nombre}=[inner sep=0mm, font=\bfseries]

\tikzstyle{pipe}=[-latex,thick,line width=4pt]

\tikzstyle{modExt}=[minimum width=1cm,inner sep=2mm,above right,draw, dotted,line width=2pt,align=center,minimum width=2cm,color=gray, font=\bfseries]

\tikzstyle{flechaFisica}=[-latex,snake=coil,segment aspect=0, red, thick];
%--------------------------

\node[módulo,fill=yellow!20](Pin){Pin};

\node[módulo, above left=0.5cm and 2cm of Pin, fill=yellow!20](CountTime){Count};

\draw[flechaFisica](Pin) -| (CountTime);

\node[módulo, above=1cm of CountTime, fill=yellow!20](CRpinCollector){Collector};

\draw[-latex](CountTime) edge (CRpinCollector);

\node[módulo, left=1cm of CRpinCollector, fill=yellow!20](CRBuffer){Buffer};

\draw[-latex](CRBuffer) edge (CRpinCollector);

\node[módulo, below=5cm of CRBuffer, fill=yellow!20](BufferReader){Cliente};

\draw[-latex](BufferReader) edge (CRBuffer);

\node[nombre, below right = 1cm and -3cm of Pin, fill=yellow!20](ConnectBufferToMCU){};

\node[componente, fit=(Pin)(CountTime)(CRBuffer)(ConnectBufferToMCU)]{};

%%------------------------------Referencias------------

\node[módulo, below left=1cm and 1cm of BufferReader, fill=yellow!20](mod){nombre};
\node[right =0.5cm of mod](modDesc){módulo};

\node[right=4cm of modDesc](x1){};
\node[right=2cm of x1](x2){};
\draw[-latex](x1)--(x2);
\node[right=0.3cm of x2](llp){llamada a procedimiento};

\node[below=0.5cm of mod.south west](x1a){};
\node[below=0.5cm of mod.south east](x2a){};
\draw[flechaFisica](x1a)--(x2a);
\node[below right=-0.4cm and 0.3cm of x2a, text width=4cm](hand){llamada a procedimiento a partir de una interrupción física (handler)};

\node[below=0.7cm of x1](x1b){};
\node[below=0.7cm of x2](x2b){};
\draw[dashed](x1b)--(x2b);
\node[right=0.3cm of x2b](rf){conexión física};
%
\node[supest, fit=(mod)(hand)(llp)]{};

\end{tikzpicture}
\label{fig:ConnectBufferToMCU}
\end{figure}



Se distinguen 4 módulos principales, \textbf{Pin} que es la representación en el diseño del hardware asociado al dispositivo que genera e introduce la interrupción, esta es manejada por \textbf{Count} que es un módulo perteneciente al patrón \textit{Command} el cual cumple la función de comando para reemplazar la utilización de \textit{callbacks}. En particular, opera sobre \textbf{Collector} almacenando en este la información relevante del evento (interrupción). Esta por lo general es un \textit{timestamp} y la cantidad de veces que sucedió.  Por ultimo, \textbf{Buffer} actúa como buffer de la información recibida, posee un método que permite obtener el valor recibido. Cuando es invocada toma los valores necesarios que se almacenan en el \textbf{Collector} y realiza los cómputos necesarios para calcular el dato pedido.

Veamos esta estructura más en detalle con un ejemplo de aplicación. Supongase que se tiene un sensor \textit{Hall} montado en una rueda y con este se quiere medir la velocidad a la que está girando la rueda. Por lo tanto, cada vez que el sensor detecte un campo magnético (ver grafico \ref{hall}) emitirá una interrupción que será manejada por el módulo \textbf{Count} que es un comando, por lo que sabe que funciones ejecutar del módulo \textbf{Collector}. 

\begin{figure}[h]
    
    \caption{Ejemplo señales emitidas por un sensor hall al detectar una variación del campo magnético. Cada pico de voltaje provoca que el microcontrolador genere una interrupción. Imagen extraída de \cite{disenioViejo2}.}
    \centering
    \includegraphics[width=0.8\linewidth]{sensorHall.png}
    \label{hall}
\end{figure}


\textbf{Count} tiene la siguiente interfaz:
\begin{itemize}
    \item \verb|execute()| registra en el acumulador el instante actual, mediante Collector::currentTime, y luego incrementa el contador de interrupciones invocando Collector::addOne.
\end{itemize}

Y el módulo \textbf{Collector}:
\begin{itemize}
    \item \verb|currentTime()|: registra internamente el momento actual de cuando el método es invocado.
    \item \verb|getCurrentTime()|: devuelve el último instante de tiempo registrado por el módulo.
    \item \verb|addOne()|: incrementa el contador interno que cuenta las ocurrencias de interrupción del sensor \textit{Hall}.
    \item \verb|total()|: retorna el valor del contador interno.
\end{itemize}

Por lo tanto cuando se pida el valor de velocidad al \textbf{Buffer} este llamará a las funciones necesarias del \textbf{Collector} para obtener información, computará el valor y lo retornará. De esta forma un cliente puede obtener la información recibida a través del pin sin necesidad de manejar las interrupciones y todas las operaciones asociadas al tratamiento de los datos.

La estructura de módulos resultante de aplicar la técnica al ejemplo seria la de la figura \ref{estructuraHall}.

\begin{figure}[H]
\caption{Ejemplo módulos para obtener la información referida a la velocidad.}
\label{estructuraHall}
\begin{center}
\scalebox{.90}{
\begin{tikzpicture}\sf

\umlclass[]{HallSensor}
{}
{
start() \\
stopt() \\
signalHandler() \\
setCommand(i: Command)
}

\umlnote[above left=1cm and -1cm of HallSensor,width=3cm]{HallSensor}
{
signalHandler() \{\\
\ \ \ \ cmd.execute() \\
\}
}

\umlclass[right=2cm of HallSensor]{Count}
{}
{
execute() \\
}

\umlnote[above=1cm of Count,width=4cm]{Count}
{
Hereda de Command \\
execute() \{ \\
\ \ \ coll.currentTime() \\
\ \ \ coll.addOne() \\
\}
}

\umlclass[below=1cm of HallSensor]{Collector}
{}
{
currentTime() \\
getCurrentTime(): Real \\
addOne() \\
preSum(): int \\
total(): int \\
periodTime(): Real \\
initPeriod()\\
}

\umlclass[right=2cm of Collector]{Buffer}
{
Buffer(i: Collector)
}
{
setConnection(i: Pipe) \\
signal() \\
}

\umlnote[below left=1.5cm and -4cm of Buffer,width=7.5cm]{Buffer}
{
signal() \{ \\
\ \ vColl.initPeriod() \\
\ \ t = vColl.periodTime()\\
\ \ nInterrup = vColl.preSum()\\
\ \ velRPM = func(t,NINTERRUP,DELTAT)\\
\ \ pipe.write(velRPM)\\
\} \\

DELTAT y NINTERRUP son constantes
}

\umlnote[left=1cm of Collector,width=4cm]{Collector}
{
addOne() \{ \\
\ \ nbr++ \}\\
\\
currentTime()\{\\
\ \ coll.currentTime()\\
\ \ if nbr == 0\\
\ \ \ \ initialT = coll.getCurrentTime()\\
\}\\
\\
getCurrentTime()\{\\
\ \ coll.getCurrentTime() \}
\\
\\
preSum()\{\\
\ \ return preN \}\\
\\
total()\{\\
\ \ return totalN \}\\
\\
periodTime()\{\\
\ \ return periodT \}\\
}

\umluniaggreg{Buffer}{Collector}
\umluniaggreg{HallSensor}{Count}

\end{tikzpicture}
}
\end{center}
\end{figure}


\subsubsection*{Periodicidad}

Algunos sistemas se encargan de mostrar, almacenar o verificar información de sensores cada cierto tiempo. No resulta crítico perder valores intermedios, es decir que no nos interesa una respuesta inmediata. Un ejemplo puede ser una estación meteorológica o un dispositivo médico de control como un tensiómetro que registra los valores de presión del paciente cada cierto periodo de tiempo.

Una implementación intuitiva es escribir un \textit{loop} y en el que se verifique la información de los sensores, llamando a ciertos métodos que obtengan esta directamente del hardware, y luego se ejecute una función \textit{sleep} que bloquea la ejecución determinada cantidad de tiempo. Esto tiene varias desventajas, primero el tiempo de ejecución la rutina alarga el periodo, si queremos agregar otras funcionalidades a realizar mientras se espera el periodo se debe dividir el \textit{sleep} y calcular tiempo de ejecución.

Una solución que parece más adecuada desde el punto de vista del diseño orientado al cambio es la siguiente. Se registra un temporizador que cada \textit{x} cantidad de tiempo gatilla una interrupción, esto es provisto por muchos entornos de desarrollo para sistemas embebidos como \gls{arduino}.
Registraremos un \textit{handler} para esta que será un módulo orden del patrón \textit{Command} el cual encapsula que funciones son necesarias ejecutar para llevar a cabo la funcionalidad deseada. Por ejemplo, pedir la información de los sensores, ya sea a sus respectivos \textbf{Buffers} (si tenemos sensores como en el ejemplo anterior) o a los sensores en si, si son de otro tipo y luego registrarla en cierta módulo (que oculte una estructura de datos). De esta forma liberamos el procesador en los tiempos de espera y desacoplamos esta funcionalidad.



\section{Control anti-rebote}
Muchos dispositivos de entrada para sistemas embebidos utilizan contacto metal con metal para indicar eventos de interés, como botones, interruptores y relés. A medida que el metal entra en contacto, se produce una deformación física que resulta en un contacto intermitente de las superficies. Esto genera señales que de no ser filtradas pueden causar una lectura errónea. 

En la bibliografía encontramos una propuesta de solución que desde mi punto de vista está más cerca de la implementación que del diseño. Esta consiste en utilizar un temporizador para dar un tiempo de gracia antes de confirmar una transición en el estado. Esto es, al percibir un cambio en la entrada se inicia el \textit{timer} y se confirma el cambio de estado solo si el valor de la entrada sigue siendo distinto que antes de percibir la modificación. 

\begin{lstlisting}[caption=Código ejemplo]
void ButtonDriver_eventReceive(ButtonDriver* const me) {
    Timer_delay(me->itsTimer, DEBOUNCE_TIME);
    if (Button_getState(me->itsButton) != me->oldState) {
        /* must be a valid button event */
        
        me->oldState = me->itsButton->deviceState;
        
        if (!me->oldState) {
            
            /* must be a button release, so update toggle value */
            if (me->toggleOn) {
                me->toggleOn = 0; /* toggle it off */
                Button_backlight(me->itsButton, 0);
                MicrowaveEmitter_stopEmitting(me->itsMicrowaveEmitter);
            }
            else {
                me->toggleOn = 1; /* toggle it on */
                Button_backlight(me->itsButton, 1);
                MicrowaveEmitter_startEmitting(me->itsMicrowaveEmitter);
            }
        }
        /* if it’s not a button release, then it must
        be a button push, which we ignore.
        */
    }
}
\end{lstlisting}

Desde el punto de vista de la IS, creo que se están combinando múltiples responsabilidades en un mismo módulo, lo cual no ayuda a lograr el objetivo de diseñar para el cambio. El estado y la decisión de transicionar son responsabilidad de un módulo, lo que puede generar inconvenientes si se quiere cambiar el criterio de aceptación de la señal, por ejemplo. Esto se evidencia en el código ejemplo del libro de Douglass donde tenemos múltiples sentencias \textit{if} anidadas. Una solución que se ajusta más a nuestros principios involucraría el patrón \textit{State} de Gamma y otro módulo que cumpla la función de verificar el cambio.

Parece ser un problema común, por ejemplo en \cite{ganssleDebouncing} se realiza un estudio de las diferentes formas en las que se manifiesta este inconveniente. Además, presenta algoritmos utilizados para determinar la ocurrencia y poder ignorarla.

\section{Máquinas de estado}\label{cap:state}


Muchos sistemas ajustan su comportamiento durante la ejecución en base a diferentes causas como interacciones externas, su propios requerimientos, etc. Por ejemplo, el sistema de control de un microondas no iniciará el calentamiento si la puerta está abierta, es decir que existe un estado interno en el que el microondas está al tener la puerta abierta y no permite cierto comportamiento que en otro estado si seria posible. De manera similar, podemos pensar que algunas partes de los sistemas responden a diferentes estados. Un ejemplo sería la dirección de giro de un motor en un robot, que podría representarse como un estado: si el motor está en un estado de "girar hacia adelante" o "girar hacia atrás", su comportamiento cambia en consecuencia. Además, si el sistema está llevando a cabo una operación, su estado podría ser \textit{trabajando}, y al finalizar, podría retornar al estado \textit{esperando}, lo que también modificaría su comportamiento. Otro ejemplo es un sistema de climatización: el estado del termostato podría ser \textit{calentando} o \textit{enfriando}, dependiendo de lo configurado por el usuario. Por lo tanto, es común enfrentarse a la gestión de estados, transiciones y todos los cambios en el comportamiento que resultan de estos.

Una solución de implementación intuitiva para aplicar estados es almacenarlos en una variable y verificar esta última para cambiar el comportamiento de las funciones. Por ejemplo:

\begin{lstlisting}[style=seudocode]
calentar() {
    if (estado == PuertaAbierta) {
        return
    } else {
        magnetron.encender()
    }
}

// otra opcion

calentar() {
    switch (estado) {
    	case PuertaAbierta {
        	return
        }
    	case otherwise {
    	    magnetron.encender()
	    }
	}
}

\end{lstlisting}

Este enfoque de es una solución directa. Sin embargo, presenta algunas desventajas cuando se desea modificar o extender el código. Por ejemplo, si se necesita agregar nuevos estados o cambiar el comportamiento del sistema, este método puede volverse rápidamente difícil de gestionar. Una de las principales desventajas es la complejidad creciente. A medida que se agregan más estados, cada función requerirá más verificaciones de estado, lo que llevará a una proliferación de estructuras \textit{if-else} o \textit{switch-case}. Esto no solo hace que el código sea más difícil de leer, sino que también aumenta la probabilidad de errores, ya que cada nuevo estado debe ser cuidadosamente incorporado en todas las partes relevantes del sistema. Además, este enfoque dificulta la sostenibilidad, cuando el comportamiento de un estado debe cambiar, es posible que se necesiten modificaciones en varias funciones. Esto puede resultar en código duplicado, o incluso puede ser difícil saber que modificar, lo que complica el proceso de realizar cambios sin introducir errores. Otra desventaja es la poca modularidad, no es claro el comportamiento asociado a cada estado. Si cada uno requiere comportamientos más complejos, el código se vuelve monolítico y difícil de extender sin alterar funciones existentes. Por ejemplo, si se agregara un estado ``EnPausa'', se tendría que modificar la lógica de muchas funciones para verificar este nuevo estado y ajustar el comportamiento de manera adecuada. Todas estas desventajas evidentemente conllevan a que reutilizar el código sea difícil.

Este tipo de soluciones es ampliamente utilizado, incluso en el software del robot desmalezar previo al trabajo realizado en \cite{paperPomponio}. En particular, se definen diferentes estados de operacion del robot, y se utiliza un gran \textit{switch-case} que es llamado en loop. En este se decide que hacer en base al estado actual. En el codigo \ref{codigoLoopMain}, podemos ver en detalle la estrategia utilizada.

\begin{lstlisting}[caption=Main loop del previo firmware del robot desmalezador, label={codigoLoopMain}]
switch (ESTADO) {
	case DUTY_REMOTO:
		duty_remoto();
		break;
	case RPM_REMOTO:
		rpm_remoto();
		break;
	case DUTY_PC:
		duty_pc();
		break;
	case RPM_PC:
		rpm_pc();
		break;	
	case CALIBRACION:
		calibracion();
		break;
	case PERDIDA_SENAL:
		perdida_senal();
		break;
	case EMERGENCIA:
		EMERGENCY();
		break;
	default:
		ESTADO = PERDIDA_SENAL;
		break;
}
\end{lstlisting}

Antes de ver un enfoque desde el punto de vista del diseño orientado al cambio, un poco mas en profundidad el ejemplo planteado en el libro y como se aplica una solución similar a la nombrada.

\subsubsection*{Transiciones basadas en eventos}.
Supongamos un sistema en donde las transiciones entre los estados son dadas por eventos particulares, por ejemplo si trabajamos con el sistema de un microondas, abrir la puerta sería un evento que desencadena una transición, apretar el botón de Cancelar mientras está calentando también. Estamos hablando de un sistema con característica de máquina de estados, en el cual el comportamiento se basa en una una sucesión de transiciones. Considere el siguiente ``\textit{state chart}'' extraído del libro que describe el funcionamiento del microondas:


\begin{figure}[h]
\caption{State chart microondas}
\begin{center}
\begin{tikzpicture}

\umlsimpleclass[fill=red!20, x=-3]{Apagado}
\umlsimpleclass[fill=red!20, x=3]{Preparado}
\umlsimpleclass[fill=red!20, x=-3, y=-3]{PuertaAbierta}
\umlsimpleclass[fill=red!20, x=3, y=-3]{Calentando}
\umlsimpleclass[fill=red!20, x=0, y=-6]{Pausa}

\umltrans[arg=prender, pos=0.5] {Apagado}{Preparado}
\umltrans[arg=cancelar, pos=1.5, geometry=|-|, anchor2=-150] {PuertaAbierta}{Preparado}
\umltrans[arg=calentarTemp, anchor1=-30, anchor2=30, pos=0.3] {Preparado}{Calentando}
\umltrans[arg=tempListo, pos=0.3] {Calentando}{Preparado}
\umltrans[arg=puertaCerrada, pos=0.5,anchor1=8, anchor2=170] {PuertaAbierta}{Calentando}
\umltrans[arg=puertaAbierta, pos=0.5,anchor1=-170, anchor2=-8] {Calentando}{PuertaAbierta}
\umltrans[arg=puertaAbierta, pos=1.2,geometry=-|] {Pausa}{PuertaAbierta}
\umltrans[arg=reanudar, pos=1.3,geometry=-|,anchor1=13, anchor2=-130] {Pausa}{Calentando}
\umltrans[arg=pausar, pos=0.7,geometry=|-,anchor1=-30, anchor2=0] {Calentando}{Pausa}
\umltrans[arg=cancelar, pos=1.3,anchor1=-13,anchor2=13,arm1=7cm,geometry=-|-]{Pausa}{Preparado}
\umltrans[arg=cancelar, pos=1.4,arm1=4cm,anchor2=-10,geometry=-|-]{Calentando}{Preparado}


\end{tikzpicture}
\end{center}
\end{figure}

Todo el funcionamiento principal del sistema es representado utilizando estados y transiciones, en cada transición se realizan cierto comportamiento relacionado con la salida del estado actual y la llegada al siguiente. Por ejemplo, si se está en el estado \textit{PuertaAbierta} y se recibe el evento \textit{puertaCerrada} se transicionará al estado \textit{Calentando}. En el proceso se encenderá el magnetrón para que este emita las ondas que finalmente calienten la comida.

A simple vista parece un comportamiento complejo y eso que solo es un ejemplo simplificado, por lo que en la vida real encontraremos casos mucho más extensos. Este es uno de los motivos por los cuales es útil contar con un buen diseño. Debemos tener en cuenta que sea fácil modificar las transiciones y también agregar y quitar estados. Doublass construye un módulo encargado de mantener el estado, el cual que sabe qué funciones ejecutar cuando se da una transición. Esto es, recibe el evento, verifica si corresponde a un cambio de estado y de ser así ejecuta el método de ``salida'' del estado actual, ejecuta el método de ``entrada'' del nuevo estado y actualiza el valor del estado actual. Además, propone una implementación utilizando una tabla bidimensional lo cual lo hace un sistema eficiente computacional hablando. En el caso de querer modificar estados, agregarlos o quitarlo es necesario cambiar la implementación de este módulo. Gamma explica esto en \cite[State]{Gamma:1995:DPE:186897}, menciona que Tom Cargill\footnote{Escritor de \textit{C++ Programming Style.Addison-Wesley}, 1992} propuso esta implementación y efectivamente es una manera de convertir código condicional en algo que se parece a una tabla.

\begin{lstlisting}[caption=Código ejemplo Douglass State Table, label={ifsanidados}]
void TokenizerStateTable_eventDispatch(TokenizerStateTable* const me, Event e) {
int takeTransition = 0;
Mutex_lock(me->itsMutex);
/* first ensure the entry is within the table boundaries */
  if (me->stateID >= NULL_STATE && me->stateID <= GN_PROCESSINGFRACTIONALPART_STATE) {
    if (e.eType >= EVDIGIT && e.eType <= EVENDOFSTRING) {
      /* is there a valid transition for the current state and event? */
      if (me->table[me->stateID][e.eType].newState != NULL_STATE) {
        /* is there a guard? */
        if (me->table[me->stateID][e.eType].guardPtr == NULL)
          /* is the guard TRUE? */
          takeTransition = TRUE; /* if no guard, then it "evaluates" to TRUE */
        else
          takeTransition =(me->table[me->stateID][e.eType].guardPtr(me));
        if (takeTransition) {
          if (me->table[me->stateID][e.eType].exitActionPtr != NULL)
            if (me->table[me->stateID][e.eType].exitActionPtr->nParams == 0)
              me->table[me->stateID][e.eType].exitActionPtr->aPtr.a0(me);
            else
              me->table[me->stateID][e.eType].exitActionPtr->aPtr.a1(me, e.ed.c);
          if (me->table[me->stateID][e.eType].transActionPtr != NULL)
            if (me->table[me->stateID][e.eType].transActionPtr->nParams == 0)
              me->table[me->stateID][e.eType].transActionPtr->aPtr.a0(me);
            else
              me->table[me->stateID][e.eType].transActionPtr->aPtr.a1(me, e.ed.c);
          if (me->table[me->stateID][e.eType].entryActionPtr != NULL)
            if (me->table[me->stateID][e.eType].entryActionPtr->nParams == 0)
              me->table[me->stateID][e.eType].entryActionPtr->aPtr.a0(me);
            else
              me->table[me->stateID][e.eType].entryActionPtr->aPtr.a1(me, e.ed.c);
          me->stateID = me->table[me->stateID][e.eType].newState;
        }
      }
    }
  }

Mutex_release(me->itsMutex);
}
\end{lstlisting}

En este ejemplo de código, que es una porción de la solución propuesta en el libro, podemos ver que aunque el enfoque cumple los requerimientos, el código no parece utilizar buenas prácticas y hace empleo de múltiples sentencias \textit{if} anidadas, lo cual complejiza el entendimiento y modificación del mismo. Por otro lado, las estructuras de datos son un item de cambio común, nuestras interfaces tienen que intentar ser independientes de la estructura de datos que se utiliza para implementarlas.

Como el otro enfoque, proponemos utilizar el patrón \textit{State} de Gamma con ciertos ajustes para permitir a los estados transicionar a otros por si mismos. Básicamente, el patrón establece la creación de un módulo por cada estado del sistema con el fin de cambiar la implementación para que se ajuste al comportamiento cuando el sistema se encuentra en dicho estado. Esto nos permite transicionar dinamicamente entre estados, ya que cambiar de estado es usar otro módulo que hereda la interfaz.

Para permitir que cada estado pueda transicionar de manera independiente a otros estados lo que hacemos es agrear una referencia de los posibles siguientes estados, para que en caso de recibir el evento adecuado pueda invocar el método de cambiar estado pasando la referencia del nuevo. Por lo tanto, al constructor de cada estado hay que agregarle como argumento cada posible estado siguiente. Esto lo podemos ver en la porción de código \ref{waitingDes} perteneciente al diseño del robot desmalezador.

\begin{lstlisting}[label={waitingDes},caption=Código ejemplo transición robot desmalezador,style=seudocode]
buildOpStates(){
    MAX=50
    workSt=new Working(mCtrlOrd)
    recSt=new Reconnecting(workSt, mCtrlOrd)
    waitSt=new WaitingMAX(workSt,recSt,ctrlsStopOrd,mCtrlOrd)
    nMax=MAX-1
    while nMax > 0
        temp=new WaitingN(workSt,waitSt,mCtrlOrd)
        waitSt=temp
        nMax--
    workSt.setNextState(waitSt)
    opState=workSt
}
\end{lstlisting}

Y para llamar a una transición de estado se ejecuta el código \ref{transicionDes}.
\begin{lstlisting}[label={transicionDes}, caption=Ejemplo transición de estado.,style=seudocode]
actionWithMsg(MainController mCtrl, Mode md){
    md.read(mCtrl)
    mCtrl.changeState(workSt) // workSt class attribute
}
\end{lstlisting}

Este uso del patrón \textit{State} también es propuesto en \cite[\textit{Chapter 10 : Finite State Machine Patterns Part III: New Patterns as Design Components}]{douglass}.


Volviendo al ejemplo del microondas, aplicando este enfoque de diseño, tendremos un módulo que provee un método que maneja cada evento y otro que delega al estado cada manejo de evento.

\begin{figure}[h!]
\caption{Módulos participantes del patrón state en el ejemplo del horno microondas.}
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}\sf
\umlclass[]{Microondas}
{}
{
prender() \\
cancelar() \\
puertaCerrada() \\
puertaAbierta() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
}

\umlclass[right=4cm of Microondas,type=abstract]{EstadoMicroondas}
{}
{
\umlvirt{prender()} \\
\umlvirt{cancelar()} \\
\umlvirt{puertaCerrada()} \\
\umlvirt{puertaAbierta()} \\
\umlvirt{reanudar()} \\
\umlvirt{calentarTemp()} \\
\umlvirt{tempListo()} \\
\umlvirt{pausar()} \\
}

\umlclass[below right=2cm and 4cm of EstadoMicroondas]{Apagado}
{}
{
changeEstate(i: Estado) \\
prender() \\
cancelar() \\
puertaCerrada() \\
puertaAbierta() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
}


\umlclass[below left=2cm and 6cm of EstadoMicroondas]{Preparado}
{
Preparado(i: Estado)
}
{
prender() \\
cancelar() \\
puertaCerrada() \\
puertaAbierta() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
}

\umlclass[below left=2cm and 0.8cm of EstadoMicroondas]{PuertaAbierta}
{
PuertaAbierta(i: Estado,\\ i: Estado)
}
{
prender() \\
cancelar() \\
puertaCerrada() \\
puertaAbierta() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
}

\umlclass[below left=2cm and -3.65cm of EstadoMicroondas]{Calentando}
{
Calentando(i: Estado,\\ i: Estado)
}
{
prender() \\
cancelar() \\
puertaCerrada() \\
puertaAbierta() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
}

\umlclass[below right=2cm and 0.2cm of EstadoMicroondas]{Pausa}
{
Pausa(i: Estado,\\ i: Estado)
}
{
prender() \\
cancelar() \\
puertaCerrada() \\
puertaAbierta() \\
reanudar() \\
calentarTemp() \\
tempListo() \\
pausar() \\
}

\umlinherit[geometry=|-|, arm1=3.75cm]{Preparado}{EstadoMicroondas}
\umlinherit[geometry=|-|, arm1=4cm]{PuertaAbierta}{EstadoMicroondas}
\umlinherit[arm1=4cm,anchor1=84]{Calentando}{EstadoMicroondas}\umlinherit[geometry=|-|, arm1=4cm]{Pausa}{EstadoMicroondas}
\umlinherit[geometry=|-|, arm1=3.802cm]{Apagado}{EstadoMicroondas}
\umluniaggreg{Microondas}{EstadoMicroondas}

\end{tikzpicture}
}
\end{center}

\end{figure}

\begin{pattern}[]{Estados del microondas}{Algorithm}{idFigAlg}
\based{Estado (State)}
\why{\textbf{Cambios previstos}: En base al estado el microondas responde a diferentes eventos de múltiples maneras. Estos estados pueden modificarse, agregar nuevos o quitar otros.

\textbf{Funcionalidad}: Cada método del módulo Microondas es un handler para un evento particular. La respuesta del sistema ante los eventos cambia en base al estado actual del mismo. Ademas, los eventos pueden desencadenar cambios de estado durante la ejecución de su handler.
}
\assigns
\is{Microondas}{Contexto}
\is{EstadoMicroondas}{Estado}
\is{Preparado}{EstadoConcreto}
\is{PuertaAbierta}{EstadoConcreto}
\is{Calentando}{EstadoConcreto}
\is{Pausa}{EstadoConcreto}
\is{Apagado}{EstadoConcreto}

\end{pattern}

Por lo tanto el módulo \textbf{PuertaAbierta} implementará el método \verb|puertaAbierta()|, completando en ella el comportamiento definido para la transición PuertaAbierta $\xrightarrow{}$ Calentando.

\begin{lstlisting}[caption=Implementación  puertaAbierta, style=seudocode]
puertaAbierta() {
    magnetron.calentar()
    microondas.changeEstate(calentando)
}
\end{lstlisting}

En cambio, en el caso del evento \textit{prender} no hará nada, pues no existe transición posible desde \textbf{PuertaAbierta} que involucre al evento \textit{prender}.

De esta forma, logramos una solución más elegante y escalable para manejar estados, superando muchas de las limitaciones del enfoque basado en verificaciones de estado dentro de las funciones. Una de las principales ventajas de este patrón es que mejora significativamente la legibilidad y modularidad del código. En lugar de manejar el comportamiento de todos los estados en una misma función, cada estado tiene su propia clase, lo que permite que el código esté mejor organizado y sea más fácil de entender. Los módulos encapsulan el comportamiento específico de cada estado, lo que elimina la necesidad de múltiples verificaciones condicionales y simplifica el flujo de ejecución. Otro beneficio importante es que facilita la adición de nuevos estados. Cuando se necesita agregar un nuevo estado, basta con definir una nueva clase que implemente el comportamiento correspondiente a ese estado, sin necesidad de modificar las funciones existentes que dependen de otros estados. Esto hace que el sistema sea mucho más flexible y escalable a medida que crece en complejidad. Además, el State elimina la duplicación de código, ya que cada clase de estado gestiona su propio comportamiento. En el enfoque tradicional, muchas funciones deben realizar repetidas verificaciones del estado y aplicar el comportamiento adecuado, lo que conduce a código repetido y potencialmente inconsistente. Una ventaja clave que mencionamos es que permite cambiar el comportamiento del sistema dinámicamente. A medida que el estado cambia, el comportamiento del objeto principal también cambia automáticamente. 

Todo esto hace que el sistema sea más robusto y adaptable, ya que los cambios de estado y las transiciones se manejan de manera interna sin depender de verificaciones externas. Cuando es necesario modificar el comportamiento de un estado, simplemente se actualiza la implementación del módulo correspondiente, lo que facilita la localización y modificación del código relevante. Y como resultado es más fácil de mantener y reduce el riesgo de introducir errores al cambiar o extender el sistema.

Existen otros casos de usos del patrón, como en los ejemplos que se nombraron al principio, puede ser usado para cambiar el comportamiento de cierta parte del sistema o a modo de configuración del mismo. El concepto principal es el mismo, crear un módulo por cada estado posible y cambiar la implementación para que se ajuste a lo requerido.

\section{Integridad de la información}
Un pulso electromagnético o fallas en el hardware pueden causar daños información dejándola comprometida, por ejemplo un \textit{bit flip}. Si los datos afectados son críticos el problema puede derivar en un error grave del sistema. Para hacer frente a esto existen diferentes técnicas, desde calcular \textit{checksums} con la intención de verificar integridad hasta almacenar la información múltiples veces. En el libro Douglass propone el uso de dos estrategias, una para datos que ocupan mucha memoria y otra para pequeños valores.

Estas estrategias suelen ser agregadas al código modificando la implementación de los métodos de la estructura de datos, o agregando verificaciones en las partes del código que utilizan la información. Es decir, se realiza por ejemplo \verb|data = data.getData()| y luego se aplican las estrategias. Lo que provoca código repetido si se llama al método \verb|getData| múltiples veces y a su vez si el dato cambia, la estrategia puede no ser mas aplicable, haciendo que se deban modificar múltiples porciones de código.

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Data}
{
value: dato \\
invertedValue: dato
}
{
    getData(): dato \\
    setData(i: dato) \\
    invert()
}

\end{tikzpicture}
\end{center}
\end{figure}

Desde el punto de vista del diseño de software se puede aportar una mirada crítica hacia las propuestas el libro, dado que plantean modificar la interfaz e implementación de los módulos encargados de almacenar la información con el objetivo de añadir esta ``capa'' de verificación. Es decir que los módulos no solo oculten como se almacena la información sino que se encarguen de verificar su integridad. 

En cambio, una posible forma de solucionar esto desde el diseño orientado al cambio es utilizar el patrón \textit{Decorator} que nos permite añadir de manera dinámica funcionalidades. En este caso, la capacidad de verificar la información. Otra ventaja, además de poder hacerlo de manera dinámica, es que mantenemos separadas las responsabilidades de cada módulo. A diferencia de los propuesto en el libro, no se combina el almacenaje de la información con su verificación, de manera que cada porción puede ser implementada de manera independiente. La solución se muestra en el gráfico \ref{decorator} con su correspondiente documentación en \ref{docDecorator}.

\begin{figure}[h]
\caption{Ejemplo \textit{Decorator} integridad de la información}
\label{decorator}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[]{Data}
{}
{
    getData(): dato \\
    setData(i: dato)
}
\umlclass[right=3cm of Data]{CRCData}
{
    calculatedCrc: crc
    errorHandler: errorHandler
}
{
    getData(): dato \\
    setData(i: dato) \\
    calcularCrc(i: dato) \\
    setErrorHandler(i: errorHandler)
}

\umlinherit{Data}{CRCData}
\umluniaggreg[anchor1=-170, anchor2=-24]{CRCData}{Data}

\end{tikzpicture}
\end{center}
\end{figure}

\begin{figure}[]
\caption{Documentación de la aplicación del patrón \textit{Decorator} al caso de verificación de la integridad de la información.}
\label{docDecorator}
\begin{pattern}[]{Modulo decorador que extiende dinámicamente las funcionalidades de otro módulo sin cambiar la implementación.}{Algorithm}{idFigAlg}
\based{Decorador (Decorator)}
\why{\textbf{Cambios previstos}: Pueden agregarse y quitarse métodos de verificación.

\textbf{Funcionalidad}: Antes de devolver la información se realiza una verificación de la integridad de la información almacenada.
}
\assigns
\is{Data}{ComponenteConcreto}
\is{CRCData}{DecoradorConcreto}

\end{pattern}
\end{figure}


\begin{lstlisting}[caption=Ejemplo de implementación métodos setData y getData,label={codDeco},style=seudocode]
setData(i: dato){
    calculatedCrc = calcularCrc(i)
    data.setData(dato)
}

getData() {
    dato = data.getData()
    if calculateCrc(dato) == calculatedCrc
        return dato
    else
        errorHandler()
}
\end{lstlisting}

De esta forma logramos añadir una capa de protección a la integridad de la información, a su vez permitimos combinar diferentes técnicas usando este patrón. Un ejemplo de la implementación de los métodos del modulo decorador se puede observar en \ref{codDeco}.

\section{Verificación de precondiciones.}
El autor del libro \cite{douglass} comenta que uno de los problemas más grandes que ve en el desarrollo de sistemas embebidos es que prácticamente todas las funciones tiene precondiciones para ejecutarse correctamente pero que casi nunca se verifica si todas estas se cumplen. Además, la manera común de informar precondiciones inadecuadas en una función en \textbf{C} es utilizando el valor de retorno (-1 en caso de errores, 0 en el contrario). Por lo tanto el encargado de manejar el error es la función o método que llamó en primer lugar a la función, generando así un acoplamiento extra entre módulos. Esto provoca una complicación derivando en muchas veces no manejarlo de la manera más adecuada. Por ejemplo, supongamos que tenemos un módulo que exporta una función que permite guardar un valor, \verb|setValor(i: Valor)|. Existen múltiples posibles implementaciones, estas son algunas:
\begin{itemize}
    \item Una posible implementación, es que la función no realice ningún chequeo y simplemente guarde en una variable el valor pasado como argumento. Esto puede generar un error en el momento si el tipo no coincide por ejemplo o en el futuro si el valor está por fuera de ciertos parámetros requeridos por el sistema. Por ejemplo, si se está almacenando un entero negativo pero se requiere que siempre sea positivo, podemos provocar un error en el futuro, si es que los clientes no chequean que sea positivo y a su vez, estamos obligando a que todos los que usen este valor deban verificar que sea positivo. Escribiendo código repetido y que en caso de que el requisito cambie deba ser actualizado manualmente.
    \item Otra forma es que la función verifique que el valor es permitido y retorne 0 o -1 en caso de que no. Esto es mejor que nada, pero como se comento en el principio estamos acoplando al usuario de la función con el módulo que la exporta, ya que este tiene que verificar el valor de retorno para determinar si existió un error o no.
\end{itemize}

Este enfoque es usado también para otro tipo de funciones como aquellas que requieren que sus argumentos cumplan cierta precondición para poder computar o realizar su trabajo. Y como Douglass comenta, esta es la realidad de la mayoría de las funciones.

La solución que se propone en el libro es una combinación de patrón y practica de programación, tiene los siguientes conceptos claves:

\begin{itemize}
    \item Construir tipos de auto-verificación siempre que sea posible
    \item Verificar los valores de los parámetros entrantes para un rango adecuado
    \item Verificar la consistencia y razonabilidad entre uno o un conjunto de parámetros
\end{itemize}

De esa manera se estaría separando la responsabilidad de verificar precondiciones de las funciones y de los clientes. Para conseguirlo se puede utilizar el patrón \textit{Proxy} al rededor de un tipo básico (un \textit{array} de \textit{ints}, por ejemplo), y de esa manera proveer múltiples funciones que permitan verificar los rangos, consistencia y demás de \textit{features} de los datos. Y en caso de detectar un problema se llamará a un módulo que cumple el rol de \textit{handler} de errores, responsable de decidir como continuar. Este uso del patrón es mencionado por Gamma en el capitulo del mismo como una posible aplicación. Es decir, realizar operaciones extras cuando se accede a un objeto. Además, comenta que se pueden agregar más funcionalidades que las que menciona Douglass, como contar la cantidad de referencias a cierto objeto con el fin de liberar la memoria si nadie lo esta referenciando, verificar si un objeto está bloqueado por otro (mutex) o controlar el acceso a la información mediante permisos.

Veamos el siguiente ejemplo, se tiene un módulo \textit{StockProducto} el cual almacena información relacionada al \textit{stock} de los productos, como es información importante se quiere añadir validaciones al momento de guardar como de extraer. Al guardar se quiere ver que la cantidad ingresada no sea negativa y al consultar se quiere estar seguro de que el usuario tiene los permisos requeridos.

\begin{figure}[h]
\caption{Uso del patrón Proxy al ejemplo del módulo stock}
\begin{center}
\begin{tikzpicture}\sf
\umlclass[type=abstract]{StockAbstracto}
{
}
{
    \umlvirt{getStock(): int} \\
    \umlvirt{setStock(i: int)}
}

\umlclass[below left=2cm and -0.5cm of StockAbstracto]{StockProducto}
{
}
{
    getStock(): int \\
    setStock(i: int)
}

\umlclass[below right=2cm and -0.5cm of StockAbstracto]{StockProxy}
{
}
{
    getStock(): int \\
    setStock(i: int)
}


\umlclass[above right=1cm and 1.5cm of StockProxy]{ErrorHandler}
{
}
{
    manejarError(i: Error)
}


\umluniassoc{StockProxy}{StockProducto}
\umlinherit[geometry=|-|]{StockProxy}{StockAbstracto}
\umlinherit[geometry=|-|]{StockProducto}{StockAbstracto}
\umluniassoc[geometry=-|-]{StockProxy}{ErrorHandler}

\end{tikzpicture}
\end{center}

\begin{pattern}[]{Acceso seguro stock de productos}{Algorithm}{idFigAlg}
\based{Proxy (Apoderado)}
\why{\textbf{Cambios previstos}: Las diferentes precondiciones a cumplir pueden variar con el tiempo.

\textbf{Funcionalidad}: Controlar el acceso al stock, en particular con el fin de preservar la integridad.
}
\assigns
\is{StockAbstracto}{Sujeto}
\is{StockProducto}{SujetoReal}
\is{StockProxy}{Proxy}

\end{pattern}

\end{figure}
ErrorHandler decide como manejar el error, esto puede ser desde loggearlo, terminar la ejecución del sistema, ignorarlo, etc. Dos tipos de estrategias comunes al tratar con errores son:
\begin{itemize}
    \item Reset de componentes: reiniciar o restablecer componentes defectuosos ayuda a borrar errores y restaurarlos a un estado funcional.
    \item Degradación elegante \cite{glass2009graceful} permite que el sistema siga funcionando a una capacidad reducida en lugar de fallar por completo. Esto implica deshabilitar las funciones que funcionan mal o cambiar a copias de seguridad, por lo que el sistema continúa funcionando con una funcionalidad limitada en lugar de apagarse por completo.
\end{itemize}


Con este diseño añadimos una capa de verificación sin modificar el módulo original, ya que \verb|getStock| y \verb|setStock| de \textit{StockProxy} van a realizar la verificación indicada y luego si todo es correcto invocarán los métodos de \textit{StockProducto}. Con esto conseguimos las siguientes ventajas:

\begin{itemize}
    \item Encapsular la lógica de validación y control de acceso en un solo lugar, sin necesidad de modificar el módulo original que gestiona los datos. Facilitando la reutilización y la separación de responsabilidades.

    \item Centraliza el control sobre cómo y cuándo se accede o modifica el dato sensible. Esto facilita la implementación de reglas de negocio más complejas, como la validación de entradas, sin tener que modificar cada parte del código que interactúa con \textbf{StockProducto}.

    \item Extender funcionalidades, el proxy puede evolucionar independientemente del modulo SujetoReal (ver \ref{patronProxy}), añadiendo nuevas funciones o cambiando las reglas de validación sin afectar la implementación original del módulo que contiene los datos. Por ejemplo, se pueden implementar restricciones de acceso, límites en las operaciones permitidas o incluso operaciones en diferido, sin necesidad de modificar el objeto real.
\end{itemize}

\section{Organización de la ejecución}

En un sistema robótico embebido se tienen que ejecutar múltiples tareas para lograr el objetivo del mismo. Ya sea, si se eligió una arquitectura de diseño de tipo ``Control de procesos'' o no, por lo general se debe verificar información recibida a través de sensores y otras fuentes (comunicación serial, web, etc), realizar cómputos y efectuar acciones con los actuadores del robot en tiempo real.

Como primer solución se considera crear funciones para cada parte del proceso y llamarlas en \textit{loop} desde la función \textit{main}, y si es necesario añadir un tiempo de espera entre cada ejecución mediante \textit{sleeps}. El principal problema que tiene este enfoque es que los sistemas robóticos son en tiempo real, es decir se pueden perder \textit{inputs} de sensores si no se los maneja de manera correcta. Además, los tiempos de espera son bloqueantes por lo que se desperdicia acceso a computo. 

Una estrategia que logra mejorar estos puntos consta de hacer uso de las interrupciones del microcontrolador permitiendo atender a todos los \textit{inputs}. En el robot desmalezador \cite{paperPomponio} esta estrategia se utiliza en conjunto con una arquitectura de control de procesos, por lo tanto existen 3 tareas principales:

\begin{itemize}
    \item Recibir información de los sensores y de la PC (por ejemplo, puerto serial).
    \item Procesar la información recibida y decidir que valores aplicar en los actuadores.
    \item Aplicar los nuevos valores a los actuadores. Notar que no es tan simple como configurar un número y dejar que actúe, en muchos casos se necesita un seguimiento durante el tiempo.
\end{itemize}

De las tareas que se tienen, dos deben ser llamadas por el sistema y la otra (recibir información) en muchos casos se dará en forma de interrupciones que el sistema debe atender. Ya se comentó de ese proceso en la sección \nameref{obtInfo}, solo es importante recordar que la estructura propuesta nos provee de una interfaz en la cual se puede invocar para obtener la información recibida de manera simple. Una vez resuelta esa cuestión ahora se debe ejecutar las otras dos tareas, dado que se quieren hacer los ajustes cada determinado tiempo, se propone crear una nueva interrupción que sea disparada de manera periódica y que su \textit{handler} se encargue de realizar todo el proceso de control y cálculo. En el manejo de esa interrupción, se accederá a la interfaces propuestas para obtener información de los sensores. Y por ultimo, para los actuadores que necesitan un seguimiento temporal para su control, se agrega una nueva interrupción que puede ser individual para el actuador y el tiempo de disparo puede estar determinado de manera particular.

Tener interrupciones periódicas puede general una bola de nieve de ejecución si el manejo de una tarda más que el tiempo entre disparos. Para prevenirlo se aplica el patrón \textit{State}, haciendo que cuando se comience a manejar la interrupción cambie el estado y toda nueva llamada al \textit{handler} resulte en un retorno rápido (solo \textit{return}). Una vez terminada la ejecución de este ciclo se cambia el estado otra vez permitiendo la ejecución de nuevos llamados. Un ejemplo de la estructura de modulos subyacente a esta solución es la que se puede ver en la figura \ref{estructuraInterrup}, seguida de la documentación del uso del patrón \textit{State}.

\begin{figure}[h!]
\caption{Ejemplo de handler usando \textit{State}.}
\label{estructuraInterrup}
\begin{center}
\begin{tikzpicture}\sf


\umlclass[type=abstract]{State}
{
}
{
    \umlvirt{handInterruption()} \\
}

\umlclass[left=2cm of State]{InterruptionHandler}
{
}
{
    handInterruption() \\
    changeState(i: State)
}

\umlclass[below left=2cm and -1cm of State]{Working}
{
}
{
    handInterruption() \\
}

\umlclass[below right=2cm and -1cm of State]{Waiting}
{
}
{
    handInterruption() \\
}

\umlnote[above right=1cm and -1.5cm of Waiting]{Waiting}{
handInterruption() \{ \\
\ \ \ \ return()\\
\}
}

\umlnote[left=1.5cm of Working,width=4cm]{Working}{
handInterruption() \{ \\
\ \ \ \ \textit{comportamiento}\\
\}
}


\umluniaggreg{InterruptionHandler}{State}
\umlinherit[geometry=|-|]{Working}{State}
\umlinherit[geometry=|-|]{Waiting}{State}



\end{tikzpicture}
\end{center}


\begin{pattern}[]{Control de manejo de interrupciones}{Algorithm}{idFigAlg}
\based{State (Estado)}
\why{\textbf{Cambios previstos}: Agregar, quitar o editar estados de manejo de la interrupción.

\textbf{Funcionalidad}: Configura el estado actual de manejo de una interrupción a fin de que una interrupción corte la ejecución de otra.
}
\assigns
\is{InterruptionHandler}{Contexto}
\is{State}{Estado}
\is{Working}{EstadoConcreto}
\is{Waiting}{EstadoConcreto}

\end{pattern}

\end{figure}



Notar que esta estrategia explota la capacidad de manejar interrupciones del microcontrolador, por lo tanto es necesario que este las soporte para llevarla a cabo.

