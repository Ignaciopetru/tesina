\chapter{Introducción}

El principal objetivo de la investigación realizada en \cite{laura} fue diseñar el software de control para un robot desmalezador que corre en un microcontrolador (MCU) situado en el robot en cuestión. Este último cuenta con cuatro ruedas y un dispositivo de dirección que les permite girar. Cada rueda tiene sensores \gls{hall}, que permiten medir su posición y velocidad, y un sistema asociado de medición de corriente. El dispositivo de dirección permite determinar su posición angular en cada momento. Tanto las ruedas como el dispositivo de dirección pueden ser operados de forma remota mediante un control remoto (RC), capaz de enviar señales de dirección y velocidad a un módulo receptor de radiofrecuencia (RF) situado en el robot. Además, una computadora (PC) situada en el robot envía órdenes al dispositivo de dirección y a las ruedas para la navegación autónoma del robot. Las órdenes provenientes tanto del RC como de la PC son procesadas por un microcontrolador ubicado en el robot.

El diseño consiste en construir y documentar módulos e interfaces siguiendo las metodologías de la Ingeniería de Software (IS), incluyendo el uso de patrones de diseño y arquitecturas de software para lograr cumplir los requerimientos propuestos. En este caso, llevar a cabo las ordenes propuestas desde la PC o el control remoto.

En \cite{laura} se propuso que el sistema se comporte de la siguiente manera. El software lleva a cabo ciclos de ejecución de forma continua para controlar el comportamiento del dispositivo de dirección y las ruedas. Durante cada ciclo de ejecución, el se procesan las órdenes provenientes del PC o del RC. Estas órdenes podrían especificar la posición angular deseada para el dispositivo de dirección, así como la velocidad, tensión o corriente deseada para las ruedas. Además, se debe realizar lecturas y mediciones de los valores actuales de posición angular, corriente y velocidad.

A partir de los valores deseados (set-points o valores de referencia) y los valores medidos, se realizan ciertos cálculos para determinar la dirección de giro y la tensión que debe aplicarse a las ruedas. El propósito es mantener los valores medidos lo más cerca posible de los valores deseados. Una vez logrado esto, se envían las señales correspondientes al dispositivo de dirección y a las ruedas.

Posteriormente, el MCU envía los valores medidos y los cálculos al PC. Luego, se inicia un nuevo ciclo de control.

Para diseñar este sistema se optó por emplear una arquitectura de control de procesos \cite[pág. 27]{ShawGarlan1996} y múltiples patrones de diseño clásicos descritos en \cite{Gamma:1995:DPE:186897}, como los patrones \textit{state}, \textit{command} o \textit{strategy}.

Como parte del trabajo, se formularon las siguientes preguntas: ¿existen patrones de diseño específicos para robótica, sistemas de control y/o sistemas embebidos? ¿Están debidamente documentados? Para intentar responderlas, se realizó una búsqueda exhaustiva y, entre los distintos resultados, destacaron dos libros: \cite{douglass} y \cite{elecia-embedded}. \cite{douglass} propone, cito textualmente, ``Design Patterns for Embedded Systems in C'' (Patrones de diseño para sistemas embebidos en C). Por lo tanto, a primera vista parece cumplir con los requisitos de la búsqueda realizada.

Esta tesina tenía como propósito inicial partir de los patrones de diseño descritos en los libros mencionados para analizarlos, adecuarlos a la documentación presentada por Gamma \cite{Gamma:1995:DPE:186897} y considerar su aplicación al diseño del robot desmalezador previamente realizado en \cite{laura}. En el primer paso, al analizar los patrones, se determinó que los "patrones" descritos en dichos libros no siguen las prácticas ni los principios establecidos por la IS, por lo cual su aplicación fue desestimada, impidiendo continuar con el desarrollo propuesto para la tesina.

\section*{Objetivos}

Al no poder utilizar los libros mencionados como fuente de patrones de diseño, la tesina tuvo que ser reorientada. En particular, se decidió utilizar los libros como fuente de problemas de diseño comunes a los que se enfrentan quienes trabajan en sistemas embebidos, robóticos y de control. El nuevo objetivo es documentar estos problemas y proponer soluciones de diseño basadas en la IS. Además, se busca contrastar las soluciones definidas en \cite{douglass} con las propuestas en la tesina, identificando ventajas, desventajas, puntos de interés e inconvenientes comunes de implementación, acompañados de ejemplos prácticos.

El trabajo, pretende ser una herramienta para desarrolladores de sistemas embebidos de control. Su objetivo es facilitar la realización de buenos diseños aplicando patrones, incluso si los desarrolladores no poseen todos los conocimientos propios de un ingeniero de software. Entre los problemas comunes seleccionados se encuentran: el acceso a diferentes componentes de hardware, es decir, establecer una interfaz que permita la comunicación con sensores o actuadores; problemas relacionados con la obtención de información a partir de diversas fuentes; el manejo de estados mediante máquinas de estados; y el control de múltiples dispositivos de manera coordinada para realizar tareas complejas que requieran cooperación. Asimismo, se incluyen otros aspectos relacionados con la estructura del código, como la organización de la ejecución explotando la capa interrupciones, la verificación de precondiciones en métodos, y la integridad de la información almacenada en memoria.

Las soluciones propuestas consisten en la aplicación de la metodología de Parnas \cite{parnas72}, el uso de patrones de diseño y la subdivisión de módulos. En algunos casos, también se presentan ejemplos de implementaciones que siguen el diseño propuesto, demostrando las ventajas de dichas soluciones.

\section*{Estructura}

A fin de brindar un conjunto de herramientas útiles y autocontenidas, se estructuró la tesina de la siguiente manera. En primer lugar, se presenta un capítulo que enumera los conceptos previos necesarios para un entendimiento completo de los problemas comunes a tratar. Además, proporciona el contexto del trabajo definiendo el tipo de sistemas abordados. En este capítulo se describen nociones generales de la ingeniería de software, tales como el diseño para el cambio, la metodología de Parnas, patrones de diseño, documentación, entre otros. También se define la arquitectura de software, que resulta clave para el tipo de software tratado en este trabajo.

El capítulo clave del trabajo es \nameref{problemasComunes}, donde se desarrolla el contenido mencionado anteriormente. Cada sección describe un problema o un conjunto de inconvenientes de la misma índole. En primer lugar, se ofrece una explicación general del problema; a continuación, se presenta la solución propuesta en el libro o la aplicada tradicionalmente, junto con los inconvenientes referidos a posibles cambios futuros que esta puede tener. Y por último, se propone una nueva solución desde el punto de vista de la IS y se enumeran las ventajas y diferencias asociadas a la misma.



