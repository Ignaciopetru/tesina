\chapter{Conceptos previos}

\section{Sistemas embebidos}
Veamos las siguientes definiciones de sistemas embebidos extraídas de diferentes autores:
\\\\
\noindent
``\textit{Un sistema computarizado dedicado a realizar un conjunto específico de funciones del mundo real, en lugar de proporcionar un entorno de computación generalizado.}''~\cite{douglass}
\\\\
\noindent
``\textit{Un sistema embebido es un sistema computarizado diseñado específicamente para su aplicación.}'' Debido a que su misión es más limitada que la de una computadora de propósito general, un sistema embebido tiene menos soporte para aspectos no relacionados con la ejecución de la aplicación.~\cite{elecia}
\\\\
\noindent
``\textit{Un sistema embebido es un sistema informático aplicado, a diferencia de otros tipos de sistemas informáticos como las computadoras personales (PCs) o las supercomputadoras.}''~\cite{noergaard2005embedded}
\\\\
\noindent		
El último autor comenta que los sistemas embebidos cumplen las siguientes afirmaciones:
\begin{itemize}
	\item Los sistemas embebidos son más limitados en funcionalidad de hardware y/o software que una computadora personal.
	\item Un sistema embebido está diseñado para realizar una función dedicada.
	\item Un sistema embebido es un sistema informático con requisitos de mayor calidad y fiabilidad que otros tipos de sistemas informáticos.
	\item Algunos dispositivos que se denominan sistemas embebidos, como los PDA\footnote{Asistentes Personales Digitales} o las tabletas web, no son realmente sistemas embebidos.
\end{itemize}

De las definiciones podemos concluir que un sistema embebido es una pieza clave que permite que el hardware especializado cumpla con su propósito específico. A diferencia de los sistemas de propósito general, el software en un sistema embebido está diseñado para interactuar estrechamente con los componentes de hardware, respondiendo en tiempo real a eventos del entorno, ya sea para controlar actuadores, monitorear sensores o gestionar comunicaciones. Este software está optimizado para requisitos específicos como velocidad, consumo energético, y confiabilidad, lo que lo hace esencial en aplicaciones críticas como dispositivos médicos, sistemas automotrices y controles industriales.
	
En resumen, el software de un sistema embebido actúa como el cerebro que dirige y coordina los recursos del hardware para realizar funciones concretas. En la tabla~\ref{tab:ejSistEmbebidos} encontramos ejemplos de dispositivos en los que se utilizan sistemas embebidos extraída de \cite{noergaard2005embedded}.

\begin{table}[h]
\caption{Ejemplos sistemas embebidos.}
    \centering
    \label{tab:ejSistEmbebidos}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Mercado} & \textbf{Dispositivo Embebido} \\ \hline
        Automotriz & Sistema de encendido \\ 
        & Control del motor \\ 
        & Sistema de frenos (Sistema Antibloqueo de Frenos - ABS) \\ \hline
        Electrónica de consumo & Decodificadores (DVDs, VCRs, Cajas de cable, etc.) \\ 
        & Asistentes Personales Digitales (PDAs) \\ 
        & Electrodomésticos (Refrigeradores, Tostadoras, Microondas) \\ 
        & Automóviles \\ 
        & Juguetes/Juegos \\ 
        & Teléfonos/Celulares/Bípers \\ 
        & Cámaras \\ 
        & Sistemas de Posicionamiento Global (GPS) \\ \hline
        Control Industrial & Sistemas de control y robótica (Manufactura) \\ \hline
        Médico & Bombas de infusión \\ 
        & Máquinas de diálisis \\ 
        & Prótesis \\ 
        & Monitores cardíacos \\ \hline
        Redes & Routers \\ 
        & Hubs \\ 
        & Puertas de enlace \\ \hline
        Automatización de Oficina & Máquinas de fax \\ 
        & Fotocopiadoras \\ 
        & Impresoras \\ 
        & Monitores \\ 
        & Escáneres \\ \hline
    \end{tabular}
    \label{tab:sistemas_embebidos}
\end{table}

Otros autores \cite{lee2017introduction} describen sistemas \textit{ciber-físicos} (CSP\footnote{por sus siglas en inglés (cyber-physical system)}) como la integración de la computación con procesos físicos. Usualmente llevada a cabo utilizando sistemas embebidos con ciclos de retroalimentación. En los cuales la parte computacional afecta al ámbito físico y viceversa. Para realizarlo se utiliza una serie de sensores y actuadores que permiten la comunicación entre ambos mundos.
Además, si tomamos en cuenta los ejemplos que se presentan tanto en \cite{noergaard2005embedded} como en \cite{lee2017introduction}, podemos decir que la mayoría de los sistemas embebidos realizan tareas de \textbf{control} sobre el mundo físico.


\section{Ingeniería de Software}
\label{ingso}

La arquitectura y el diseño del software se consideran herramientas esenciales para lograr atributos importantes de calidad del software, como la modificabilidad, reusabilidad, mantenibilidad, etc.\cite{ShawGarlan1996, ghezzi2003, bass2003, DBLP:books/daglib/0030743}
Tradicionalmente, el software para robots tiende a desarrollarse de manera monolítica, con pocas funciones de gran tamaño y numerosos condicionales anidados, o mediante una descomposición funcional básica que resulta ineficiente para mantener y reutilizar componentes \cite{code-1,code-2}. Frente a esto, se propone un diseño sistemático basado en principios de la ingeniería de software, aplicados para anticipar y manejar los cambios \cite{Gamma:1995:DPE:186897, DBLP:books/lib/BuschmannHS07}.

El diseño para el cambio, como principio fundamental, se centra en prever modificaciones probables en el software \cite{Parnas1972, ShawGarlan1996, ghezzi2003, bass2003, DBLP:books/daglib/0030743}, ya sea por cambios en los objetivos de comportamiento, en el hardware o en los algoritmos de control. Diseñar anticipando estos cambios permite reducir los esfuerzos necesarios para implementar ajustes y facilita la reutilización de componentes en familias de software\footnote{en este caso familias de robots} que comparten funcionalidades similares pero adaptadas a diferentes plataformas de hardware\cite{Parnas02, DBLP:books/daglib/0019719}.

Para abordar estos retos, el diseño modular es clave \cite{Parnas1972}. Este enfoque organiza el software como un conjunto de módulos simples con responsabilidades claramente definidas y relaciones explícitas entre ellos. Cada módulo se diseña para ocultar información específica y gestionar un cambio probable de forma aislada, lo que minimiza el impacto de las modificaciones en el resto del sistema. Por ejemplo, si un sensor cambia su forma de reportar datos, el ajuste puede limitarse al módulo responsable de interactuar con ese sensor.

Además, el principio de diseño abierto-cerrado \cite{DBLP:books/ph/Meyer97} se implementa para garantizar que el sistema pueda extenderse mediante nuevos módulos en lugar de modificar los existentes, reduciendo el riesgo de introducir errores al alterar componentes ya probados. Es decir, que un sistema debe estar abierto a extensiones pero cerrado a modificaciones \cite{DBLP:books/ph/Meyer97}. Esto se complementa con la aplicación de patrones de diseño y estilos arquitectónicos, que aportan soluciones probadas para manejar cambios recurrentes en dominios específicos \cite{Gamma:1995:DPE:186897, DBLP:books/lib/BuschmannHS07}. Por ejemplo, en sistemas robóticos, un estilo arquitectónico basado en bucles de control puede destacar las características esenciales del sistema y facilitar decisiones de diseño óptimas \cite{ShawGarlan1996}.

\subsection{Metodología de Parnas}

La metodología de \textbf{Parnas}\cite{Parnas1972}, conocida como Diseño Basado en Ocultación de la Información (DBOI), es una estrategia de diseño modular que tiene como objetivo preparar los sistemas de software para gestionar el cambio de manera eficiente y con el menor costo posible. Esta metodología parte del principio de que los requerimientos de un sistema no son inmutables, sino que evolucionarán durante su vida útil. Por ello, el diseño debe anticipar y facilitar la incorporación de cambios sin comprometer la integridad del sistema.

\noindent\fbox{\begin{minipage}{\textwidth}
Principio de Ocultación de la Información: Los ítem con alta probabilidad de cambio son el fundamento para descomponer un sistema en módulos. Cada módulo de la descomposición debe ocultar un \textbf{único} ítem con alta probabilidad de cambio, y debe ofrecer a los demás módulos una interfaz insensible a los cambios anticipados. \cite{Parnas1972}
\end{minipage}} 
\\\\
\indent
El núcleo de esta metodología es la identificación de los ítems con alta probabilidad de cambio dentro del sistema. Estos ítems representan aspectos de diseño o implementación susceptibles de modificaciones futuras, como algoritmos, estructuras de datos, interfaces con hardware o incluso requerimientos del usuario (ver lista estendida en \ref{listaItems}). Una vez identificados, Parnas sugiere aislar cada ítem en módulos independientes, asegurando que cada módulo oculte las decisiones de diseño específicas que podrían cambiar. Esto se logra diseñando interfaces que no expongan detalles de implementación, permitiendo que los módulos interactúen sin conocer sus detalles internos.

La razón por la que queremos aplicar esta metodología es clara: minimizar los costos asociados al desarrollo y mantenimiento del software. Al aislar las áreas susceptibles de cambio, cualquier modificación futura afectará únicamente al módulo correspondiente, sin propagarse al resto del sistema. Además, esta aproximación mejora la capacidad de escalar el sistema, facilita la colaboración en equipos de desarrollo grandes y permite que diferentes programadores trabajen en módulos específicos de manera independiente.

La metodología de Parnas nos ayuda a diseñar para el cambio porque impone una disciplina clara en la forma en que los módulos se estructuran e interactúan. Al encapsular las decisiones de diseño que podrían cambiar, evitamos la degradación de la integridad conceptual del sistema y reducimos significativamente el riesgo de introducir errores al realizar modificaciones. En definitiva, el DBOI fomenta un diseño robusto y adaptable, preparado para enfrentar la evolución inevitable de los sistemas de software.


Los pasos de la metodología son:

\begin{enumerate}
	\item Identificar los ítem con probabilidad de cambio presentes en los requerimientos.
	\item Analizar la diversas formas en que cada ítem puede cambiar.
	\item Se asigna una probabilidad de cambio a cada variación analizada.
	\item Aislar en módulos separados los ítem cuya probabilidad de cambio sea alta; implícitamente este punto indica que en cada módulo se debe aislar un único ítem con probabilidad de cambio.
	\item Diseñar las interfaces de los módulos de manera que resulten insensibles a los cambios anticipados.

\end{enumerate}



\subsection{Items de cambio comunes}
\label{listaItems}

Cuando se diseña pensando en el cambio, una tarea que se agrega es identificar las características o requerimientos del sistema que pueden variar en el tiempo. Naturalmente existen elementos que son mas probables a cambiar que otros, por lo que resulta importante anticiparse a esos cambios en particular. Algunos autores mencionaron algunos items de cambio comunes entre múltiples sistemas \cite{Parnas02}.

\begin{itemize}
	\item Contracción o extension de requisitos.
	\item Configuraciones de hardware.
	\item Formato de los datos de entrada y salida.
	\item Estructuras de datos.
	\item Algoritmos.
	\item Algunos usuarios pueden requerir solo un subconjunto de los servicios o características que otros usuarios necesitan.
	\item Dispositivos periféricos.
	\item Entorno socio-cultural (moneda, impuestos, fechas, idioma, etc.).
	\item Cambios propios del dominio de aplicación.
	\item Cambios propios del negocio de la compañía desarrolladora.
	\item Interconexión con otros sistemas.
\end{itemize}

Es útil consultar estos items a la hora de diseñar siguiendo los criterios de modularización de \cite{Parnas1972}.


\subsection{Patrones de Diseño}

En \cite{Gamma:1995:DPE:186897}, el autor trae a colación la definición de patrón de diseño que dio Christopher Alexander:

\textit{``cada patrón describe un problema que ocurre una y otra vez en nuestro entorno, así como la solución al problema, de modo que pueda aplicarse un millón de veces esta solución sin hacer lo mismo dos veces''}

Christopher era arquitecto, pero su definición puede ser aplicada al ámbito del software, en lugar de paredes, vigas y columnas, trabajamos con módulos e interfaces.

Un patrón tiene tres elementos principales:

\begin{itemize}
	\item El \textbf{problema} al que se intenta dar solución. Posee una explicación del mismo, con el fin de que el usuario pueda saber si aplica o no a su situación en cuestión.
	\item La \textbf{solución} al problema, dada como los elementos de del diseño, sus relación responsabilidades y colaboraciones. Es una plantilla que puede ser aplicada en diferentes condiciones.
	\item Las \textbf{consecuencias}, que son los resultados de aplicar esta solución. Es decir, que beneficios y costos obtenemos de la aplicación. Así como las formas que el patrón provee para anticiparse a los posibles cambios futuros.
\end{itemize}

Determinar que es o no un patrón resulta objetivo, pero utilizaremos el mismo criterio que el autor de \cite{Gamma:1995:DPE:186897}:

\textit{```descripciones de módulos relacionados que están particularizados para resolver un problema de diseño general en un determinado contexto''}

Notar no solo se quiere saber como resolver un problema, sino que se busca que la solución se alinee con los principios de la ingeniería de software y provea un buen diseño que permita lograr las propiedades que se buscan, modificabilidad, reusabilidad, mantenibilidad, etc. Esto será importante para diferenciar algunos ``patrones de diseño'' que no tiene en cuenta el objetivo mencionado.

Para anticiparse al cambio, los patrones aseguran que un sistema pueda cambiar de manera concreta, es decir, que se deja que algún aspecto de la estructura varíe de manera independiente y esperada.


\subsection{Arquitectura de software}

Según \cite{ShawGarlan1996} la arquitectura de software se define como la estructura fundamental de un sistema de software, que está compuesta por sus componentes y las relaciones entre estos. Este campo aborda la organización y los patrones utilizados para estructurar los sistemas de software de manera que sean eficientes, sostenibles y capaces de manejar cambios a lo largo del tiempo.

Se destaca que la arquitectura de software no solo se trata de la estructura del código o la implementación técnica, sino de las decisiones de alto nivel que afectan la organización y el comportamiento del sistema. Estas decisiones incluyen cómo dividir un sistema en partes modulares, qué patrones arquitectónicos aplicar para facilitar la extensión y el mantenimiento, y cómo gestionar las interacciones entre diferentes componentes del sistema. Notar que cuando se habla de componentes estos pueden estar formados por múltiples módulos, son de una capa de abstracción superior a los conceptos que se manejan cuando hablamos de patrones de diseño.


\section{Arquitectura Control de Procesos}

Si nos centramos en los sistemas embebidos de control, encontramos que existen trabajos sobre arquitecturas de software orientadas al control de procesos, por ejemplo el estilo arquitectónico de \textit{Control del Procesos} presentado en \cite{ShawGarlan1996}. El mismo está definido para ser usado en sistemas de control donde se quiere mantener ciertas propiedades de la salida del proceso cerca de valores de referencia. Como por ejemplo la velocidad de giro de una rueda, la posición del extrusor de una impresora 3D, la temperatura del agua en una caldera, etc.

Para llevar a cabo el enfoque se fundamenta en tres componentes básicos: \textbf{Control}, \textbf{Proceso} y \textbf{Sensores}, los cuales trabajan de manera independiente.

\begin{figure}[h!]
\caption{Diagrama de la arquitectura control de procesos}
\label{fig:arqCtrlRobot}
\vspace{0.5cm}
\centering
\begin{tikzpicture}\hypertarget{fig:arqCtrlRobot}{}

\tikzstyle{moduloL}=[minimum width=3cm, minimum height=1.5cm,inner sep=2mm,above right,draw,align=center, font=\scshape] 

\tikzstyle{supest}=[rounded corners=1.5mm, minimum width=2cm,inner sep=2mm,draw,text width=2cm]

\tikzstyle{nombre}=[inner sep=0mm, font=\bfseries]

\tikzstyle{pipe}=[-latex,thick,line width=4pt]

\tikzstyle{nombreLogico}=[inner sep=0mm, font=\scshape, minimum width=1.5cm]

%---figura control-----
\tikzstyle{ctrl}=[shape=circle,draw,minimum width=2.5cm,text width=2cm, inner sep=2, align=center,font=\scshape];


%----figura de sensor---
\tikzstyle{sensor}=[draw,circle, minimum width=1cm,after node path={(\tikzlastnode) circle (0.2cm)}]
% se usa así: \draw node[sensor]{};

%---------------------------------------
%---control del proceso rueda----
\node[ctrl, text width=1.8cm] (0,0) (controlR){Control};
%
\node[moduloL, below=2cm of controlR, minimum width=5cm](proceso){Proceso};
%%
\draw node[sensor, below =2cm of proceso.-160](sensorVel){};
\draw node[sensor, below=2cm of proceso.-110](sensorCte){};
\draw node[sensor, below=2cm of proceso.-20](sensorDir){};
%%
%%%puntos para hacer las flechas de las señales hacia los sensores
\node[below=4.5cm of proceso.-160](pto1){};
\node[below=4.5cm of proceso.-110](pto2){};
\node[below=4.5cm of proceso.-20](pto3){};
%%
\draw[dashed, -latex](proceso.-160)--(pto1);
\draw[dashed, -latex](proceso.-110)--(pto2);
\draw[dashed, -latex](proceso.-20)--(pto3);
%%
\node[nombreLogico, below left=-0.1cm and 0.1cm of sensorVel, text width=1.5cm]{Sensor};
\node[nombreLogico, above right=0.2cm and -0.1cm of sensorCte, text width=1.5cm]{Sensor};
\node[nombreLogico, below right=0.2cm and -0.1cm of sensorDir, text width=1.5cm]{Sensor};
%%
%%%---pipes
\draw[pipe] (sensorVel.west) -| (-3.3,-4) |- (controlR.south west);
\draw[pipe] (sensorCte.south) |- (-4.5,-8.7) |- (controlR.west);
\draw[pipe] (sensorDir.east) -| (3.5,-4) |- (controlR.east);
%
%%

\draw[-latex](controlR.250) -- (proceso.120);
\draw[-latex](controlR.-70) -- (proceso.60);
%%
\node[below left=0.7cm and -0.7cm of controlR, text width=1.3cm]{};
\node[below right=0.7cm and -0.5cm of controlR, text width=1.3cm]{};
%%
%


%---Referencias---
\node[below left=3.5cm and 4cm of sensorVel](f11){};
\node[below left=3.5cm and 2cm of sensorVel](f12){};
\draw[*-latex] (f11) edge node[above](f1){evento} (f12);

\node[below left=3.5cm and 2cm of sensorCte](f21){};
\node[below left=3.5cm and 0cm of sensorCte](f22){};
\draw[-latex] (f21) edge node[above, text width =2.1cm](f2){llamada a\\ procedimiento} (f22);


\node[below left=3.5cm and 1cm of sensorDir](f31){};
\node[below right=3.5cm and 1cm of sensorDir](f32){};
\draw[dashed,-latex] (f31) edge node[above, text width =1.5cm](f3){respuesta física}
 (f32);
 
\node[below right=3.5cm and 2.5cm of sensorDir](f41){};
\node[below right=3.5cm and 4.5cm of sensorDir](f42){};
\draw[pipe] (f41) edge node[above, text width =1.5cm]{tubo}
 (f42);
 
\node[shape=circle,draw,minimum width=1.2cm,below=1.5cm of f1,label={above,text width=1.7cm:algoritmo\\ de control}](c){};

\node[shape=rectangle,draw,minimum width=1.5cm,minimum height=0.8cm ,below=1.5cm of f2,label={above:proceso}](p){};

\draw node[below=1.5cm of f3,draw,circle, minimum width=1cm,after node path={(\tikzlastnode) circle (0.2cm)}, label={above:sensor}]{};
 
\node[supest, fit=(f11)(f2)(f32)(f42)(c)(p)]{};
\end{tikzpicture}
\end{figure}

El componente \textbf{Control} es responsable de implementar el algoritmo de control, procesar datos provenientes de los sensores y realizar ajustes al proceso para mantener las variables dentro de los valores deseados. Además, se encarga de activar y desactivar el sistema, y de configurar los rangos de operación o \textit{set-points}. Por otro lado, el \textbf{Proceso} encapsula los dispositivos que generan las salidas controladas, proporcionando interfaces para modificar sus variables según las instrucciones del \textbf{Control}. Finalmente, los \textbf{Sensores} miden las variables clave del proceso y transmiten estos datos al componente \textbf{Control}, ocultando la complejidad de los dispositivos de medición.

Esta arquitectura emplea conectores como eventos, llamadas a procedimiento y tubos (pipes) para gestionar la comunicación y las acciones entre los componentes. A nivel computacional, el sistema funciona en un ciclo continuo de retroalimentación donde los sensores miden las variables, el \textbf{Control} evalúa estas mediciones y, de ser necesario, ajusta el \textbf{Proceso} para garantizar el cumplimiento de los objetivos definidos. Este enfoque modular facilita la incorporación de nuevos sensores, actualizaciones en el algoritmo de control y cambios en el hardware, promoviendo flexibilidad y escalabilidad.

\begin{table}[h!]
\label{tab:conceptosArq}
\caption{Conceptos clave en la arquitectura de control de procesos.}

\setlength{\extrarowheight}{5pt} % Incrementa el espacio vertical entre filas
\renewcommand{\arraystretch}{1.0} % Ajusta el espacio vertical adicional en las celdas
\begin{tabular}{|>{\raggedright\arraybackslash}p{4.5cm}|>{\raggedright\arraybackslash}p{10.5cm}|}
\hline
\textbf{Término}               & \textbf{Definición}                                                                                                                                       \\ \hline
\textbf{Variable del proceso}  & Propiedades del proceso que pueden medirse y monitorearse, como temperatura, presión, flujo o velocidad. Estas variables reflejan el estado del sistema. \\ \hline
\textbf{Variable controlada}   & Una variable del proceso cuyo valor el sistema intenta mantener en un rango deseado, como la temperatura de un horno o el nivel de agua en un tanque.    \\ \hline
\textbf{Variable manipulada}   & Variable del proceso que el controlador puede ajustar directamente para influir en la variable controlada, como la válvula de flujo en un sistema de bombeo. \\ \hline
\textbf{Variable de entrada}   & Variable que mide una entrada al proceso, como la potencia suministrada a un motor o la cantidad de material en una cinta transportadora.               \\ \hline
\textbf{Set Point}             & El valor deseado para una variable controlada. El controlador busca ajustar el sistema para alcanzar y mantener este valor.                              \\ \hline

\end{tabular}
\end{table}



