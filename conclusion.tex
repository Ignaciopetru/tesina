\chapter{Conclusión}
\label{conclusion}

A lo largo de este trabajo se exploró un conjunto de problemáticas recurrentes en el desarrollo de sistemas embebidos de control, poniendo en evidencia cómo la falta de preparación ante el cambio puede derivar en diseños rígidos, difíciles de mantener y costosos de evolucionar. Estos problemas, comunes en la práctica profesional, no se limitan a cuestiones de bajo nivel como el manejo de periféricos o la eficiencia en tiempo de ejecución, sino que se relacionan con la organización misma del software y con la capacidad de anticiparse a los cambios en el hardware, en los requerimientos funcionales o en el entorno de uso.

Frente a este panorama, se adoptó la perspectiva de la \gls{IS} centrada en el diseño para el cambio, siguiendo las ideas fundamentales propuestas por David L. Parnas. Esta visión propone identificar explícitamente los ítems de cambio y encapsularlos dentro de módulos bien definidos, de modo que una modificación futura impacte en la menor cantidad posible de componentes. Bajo este enfoque, se analizaron diferentes ejemplos tomados tanto de la literatura \cite{douglass} como del trabajo realizado sobre el robot desmalezado \cite{paperPomponio}, y se propusieron soluciones basadas en estructuras modulares y patrones de diseño.

En particular, se mostró cómo patrones clásicos como \textit{State}, \textit{Strategy}, \textit{Adapter}, \textit{Command}, \textit{Decorator} y \textit{Mediator} permiten abordar de forma sistemática problemas habituales en el software embebido. El patrón \textit{State} resultó útil para representar transiciones claras entre estados de un dispositivo físico, evitando estructuras rígidas con múltiples sentencias condicionales. \textit{Strategy} ofreció un mecanismo para variar criterios de decisión sin afectar la estructura global del sistema. \textit{Adapter} permitió integrar librerías de distintos fabricantes sin necesidad de reescribir todo el código cliente, \textit{Command} brindó una manera ordenada de manejar eventos e interrupciones. \textit{Decorator} posibilitó añadir funcionalidades dinámicamente a módulos y \textit{Mediator} organizó la coordinación entre subsistemas para lograr objetivos comunes. Estos ejemplos evidencian que los patrones de diseño, originalmente concebidos para software de propósito general, pueden trasladarse con éxito al ámbito embebido siempre que se adapten a sus restricciones particulares de recursos y desempeño.

Otro aspecto importante del trabajo fue la discusión del estilo arquitectónico de control de procesos, el cual permitió enmarcar el diseño de los sistemas embebidos de control en una visión más amplia, donde las actividades de adquisición de datos, procesamiento y actuación se organizan en una estructura sistemática. Este estilo arquitectónico ofrece un marco conceptual que facilita la integración de nuevos dispositivos y algoritmos sin afectar la lógica central de control. Asimismo, la estructura modular para la obtención de información se destacó como una estrategia clave para desacoplar el hardware de los mecanismos de cómputo, permitiendo que los datos se capturen, almacenen y procesen de manera flexible y reutilizable.

El aporte central de esta tesina puede interpretarse como la construcción de una caja de herramientas conceptual para desarrolladores de sistemas embebidos que no tengan mucha experiencia en el diseño de software. Esta caja de herramientas no pretende ofrecer recetas únicas ni soluciones rígidas, sino marcos de referencia que permitan razonar ante la necesidad de cambio. La idea es que, frente a un problema práctico, el diseñador disponga de un repertorio de enfoques probados que le permitan seleccionar, adaptar y combinar las técnicas más adecuadas a cada contexto. Así, el diseño para el cambio se transforma en un hábito metodológico que guía las decisiones y no en una actividad reactiva que aparece recién cuando los problemas ya se han manifestado.

El trabajo también resalta la importancia de integrar prácticas de la \gls{IS} en el campo de los sistemas embebidos. Tradicionalmente, el diseño en este ámbito ha estado orientado de manera casi exclusiva a la eficiencia y al aprovechamiento máximo del hardware disponible. Sin embargo, los ejemplos desarrollados demuestran que un diseño flexible y mantenible no solo no va en contra de la eficiencia, sino que puede convertirse en una ventaja competitiva al prolongar la vida útil de los productos, facilitar la actualización tecnológica y reducir los costos de mantenimiento a largo plazo.

En síntesis, vimos que el diseño para el cambio constituye un enfoque valioso en el desarrollo de software embebido. Su aplicación consciente, junto con el apoyo de estilos arquitectónicos como el control de procesos y estructuras modulares, contribuye a construir sistemas más robustos, escalables y preparados para la evolución constante del entorno tecnológico. Al mismo tiempo, ofrece a los desarrolladores una forma de organizar su trabajo con mayor previsión, reduciendo el riesgo de introducir errores y favoreciendo la reutilización de componentes.

Un aspecto que merece ser destacado es que, durante el análisis, muchos de los supuestos patrones de diseño encontrados en la literatura no respondían en realidad a los criterios de la \gls{IS}, sino que resultaban ser patrones idiomáticos, ligados a características específicas de implementación o a convenciones de un lenguaje en particular. Esto muestra que, en la práctica, aquello que inicialmente considerábamos ``patrones de diseño'' no siempre cumplía con los principios de modularidad, ocultación de información y preparación para el cambio propuestos por la \gls{IS}. Reconocer esta diferencia no es un detalle menor: permitió replantear los objetivos de la tesina, orientar el trabajo hacia soluciones que sí se alineen con las buenas prácticas de la disciplina y, al mismo tiempo, resalta la necesidad de que el diseño en sistemas embebidos no se quede en soluciones idiomáticas de bajo nivel, sino que adopte un enfoque más robusto y fundamentado en la Ingeniería de Software.



